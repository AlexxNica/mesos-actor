// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO2

package org.apache.mesos.v1.mesos

/** *
  * Encapsulation of `Capabilities` supported by Linux.
  * Reference: http://linux.die.net/man/7/capabilities.
  */
@SerialVersionUID(0L)
final case class CapabilityInfo(
    capabilities: _root_.scala.collection.Seq[org.apache.mesos.v1.mesos.CapabilityInfo.Capability] = _root_.scala.collection.Seq.empty
    ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[CapabilityInfo] with com.trueaccord.lenses.Updatable[CapabilityInfo] {
    @transient
    private[this] var __serializedSizeCachedValue: Int = 0
    private[this] def __computeSerializedValue(): Int = {
      var __size = 0
      capabilities.foreach(capabilities => __size += _root_.com.google.protobuf.CodedOutputStream.computeEnumSize(1, capabilities.value))
      __size
    }
    final override def serializedSize: Int = {
      var read = __serializedSizeCachedValue
      if (read == 0) {
        read = __computeSerializedValue()
        __serializedSizeCachedValue = read
      }
      read
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
      capabilities.foreach { __v =>
        _output__.writeEnum(1, __v.value)
      };
    }
    def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): org.apache.mesos.v1.mesos.CapabilityInfo = {
      val __capabilities = (_root_.scala.collection.immutable.Vector.newBuilder[org.apache.mesos.v1.mesos.CapabilityInfo.Capability] ++= this.capabilities)
      var _done__ = false
      while (!_done__) {
        val _tag__ = _input__.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case 8 =>
            __capabilities += org.apache.mesos.v1.mesos.CapabilityInfo.Capability.fromValue(_input__.readEnum())
          case 10 => {
            val length = _input__.readRawVarint32()
            val oldLimit = _input__.pushLimit(length)
            while (_input__.getBytesUntilLimit > 0) {
              __capabilities += org.apache.mesos.v1.mesos.CapabilityInfo.Capability.fromValue(_input__.readEnum)
            }
            _input__.popLimit(oldLimit)
          }
          case tag => _input__.skipField(tag)
        }
      }
      org.apache.mesos.v1.mesos.CapabilityInfo(
          capabilities = __capabilities.result()
      )
    }
    def clearCapabilities = copy(capabilities = _root_.scala.collection.Seq.empty)
    def addCapabilities(__vs: org.apache.mesos.v1.mesos.CapabilityInfo.Capability*): CapabilityInfo = addAllCapabilities(__vs)
    def addAllCapabilities(__vs: TraversableOnce[org.apache.mesos.v1.mesos.CapabilityInfo.Capability]): CapabilityInfo = copy(capabilities = capabilities ++ __vs)
    def withCapabilities(__v: _root_.scala.collection.Seq[org.apache.mesos.v1.mesos.CapabilityInfo.Capability]): CapabilityInfo = copy(capabilities = __v)
    def getFieldByNumber(__fieldNumber: Int): scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => capabilities.map(_.javaValueDescriptor)(_root_.scala.collection.breakOut)
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PRepeated(capabilities.map(__e => _root_.scalapb.descriptors.PEnum(__e.scalaValueDescriptor))(_root_.scala.collection.breakOut))
      }
    }
    override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
    def companion = org.apache.mesos.v1.mesos.CapabilityInfo
}

object CapabilityInfo extends com.trueaccord.scalapb.GeneratedMessageCompanion[org.apache.mesos.v1.mesos.CapabilityInfo] {
  implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[org.apache.mesos.v1.mesos.CapabilityInfo] = this
  def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): org.apache.mesos.v1.mesos.CapabilityInfo = {
    require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
    val __fields = javaDescriptor.getFields
    org.apache.mesos.v1.mesos.CapabilityInfo(
      __fieldsMap.getOrElse(__fields.get(0), Nil).asInstanceOf[_root_.scala.collection.Seq[_root_.com.google.protobuf.Descriptors.EnumValueDescriptor]].map(__e => org.apache.mesos.v1.mesos.CapabilityInfo.Capability.fromValue(__e.getNumber))(_root_.scala.collection.breakOut)
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[org.apache.mesos.v1.mesos.CapabilityInfo] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
      org.apache.mesos.v1.mesos.CapabilityInfo(
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.collection.Seq[_root_.scalapb.descriptors.EnumValueDescriptor]]).getOrElse(_root_.scala.collection.Seq.empty).map(__e => org.apache.mesos.v1.mesos.CapabilityInfo.Capability.fromValue(__e.number))(_root_.scala.collection.breakOut)
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = MesosProto.javaDescriptor.getMessageTypes.get(56)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = MesosProto.scalaDescriptor.messages(56)
  def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__fieldNumber)
  def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = {
    (__fieldNumber: @_root_.scala.unchecked) match {
      case 1 => org.apache.mesos.v1.mesos.CapabilityInfo.Capability
    }
  }
  lazy val defaultInstance = org.apache.mesos.v1.mesos.CapabilityInfo(
  )
  sealed trait Capability extends _root_.com.trueaccord.scalapb.GeneratedEnum {
    type EnumType = Capability
    def isUnknown: Boolean = false
    def isChown: Boolean = false
    def isDacOverride: Boolean = false
    def isDacReadSearch: Boolean = false
    def isFowner: Boolean = false
    def isFsetid: Boolean = false
    def isKill: Boolean = false
    def isSetgid: Boolean = false
    def isSetuid: Boolean = false
    def isSetpcap: Boolean = false
    def isLinuxImmutable: Boolean = false
    def isNetBindService: Boolean = false
    def isNetBroadcast: Boolean = false
    def isNetAdmin: Boolean = false
    def isNetRaw: Boolean = false
    def isIpcLock: Boolean = false
    def isIpcOwner: Boolean = false
    def isSysModule: Boolean = false
    def isSysRawio: Boolean = false
    def isSysChroot: Boolean = false
    def isSysPtrace: Boolean = false
    def isSysPacct: Boolean = false
    def isSysAdmin: Boolean = false
    def isSysBoot: Boolean = false
    def isSysNice: Boolean = false
    def isSysResource: Boolean = false
    def isSysTime: Boolean = false
    def isSysTtyConfig: Boolean = false
    def isMknod: Boolean = false
    def isLease: Boolean = false
    def isAuditWrite: Boolean = false
    def isAuditControl: Boolean = false
    def isSetfcap: Boolean = false
    def isMacOverride: Boolean = false
    def isMacAdmin: Boolean = false
    def isSyslog: Boolean = false
    def isWakeAlarm: Boolean = false
    def isBlockSuspend: Boolean = false
    def isAuditRead: Boolean = false
    def companion: _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[Capability] = org.apache.mesos.v1.mesos.CapabilityInfo.Capability
  }
  
  object Capability extends _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[Capability] {
    implicit def enumCompanion: _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[Capability] = this
    @SerialVersionUID(0L)
    case object UNKNOWN extends Capability {
      val value = 0
      val index = 0
      val name = "UNKNOWN"
      override def isUnknown: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object CHOWN extends Capability {
      val value = 1000
      val index = 1
      val name = "CHOWN"
      override def isChown: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object DAC_OVERRIDE extends Capability {
      val value = 1001
      val index = 2
      val name = "DAC_OVERRIDE"
      override def isDacOverride: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object DAC_READ_SEARCH extends Capability {
      val value = 1002
      val index = 3
      val name = "DAC_READ_SEARCH"
      override def isDacReadSearch: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object FOWNER extends Capability {
      val value = 1003
      val index = 4
      val name = "FOWNER"
      override def isFowner: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object FSETID extends Capability {
      val value = 1004
      val index = 5
      val name = "FSETID"
      override def isFsetid: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object KILL extends Capability {
      val value = 1005
      val index = 6
      val name = "KILL"
      override def isKill: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object SETGID extends Capability {
      val value = 1006
      val index = 7
      val name = "SETGID"
      override def isSetgid: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object SETUID extends Capability {
      val value = 1007
      val index = 8
      val name = "SETUID"
      override def isSetuid: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object SETPCAP extends Capability {
      val value = 1008
      val index = 9
      val name = "SETPCAP"
      override def isSetpcap: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object LINUX_IMMUTABLE extends Capability {
      val value = 1009
      val index = 10
      val name = "LINUX_IMMUTABLE"
      override def isLinuxImmutable: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object NET_BIND_SERVICE extends Capability {
      val value = 1010
      val index = 11
      val name = "NET_BIND_SERVICE"
      override def isNetBindService: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object NET_BROADCAST extends Capability {
      val value = 1011
      val index = 12
      val name = "NET_BROADCAST"
      override def isNetBroadcast: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object NET_ADMIN extends Capability {
      val value = 1012
      val index = 13
      val name = "NET_ADMIN"
      override def isNetAdmin: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object NET_RAW extends Capability {
      val value = 1013
      val index = 14
      val name = "NET_RAW"
      override def isNetRaw: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object IPC_LOCK extends Capability {
      val value = 1014
      val index = 15
      val name = "IPC_LOCK"
      override def isIpcLock: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object IPC_OWNER extends Capability {
      val value = 1015
      val index = 16
      val name = "IPC_OWNER"
      override def isIpcOwner: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object SYS_MODULE extends Capability {
      val value = 1016
      val index = 17
      val name = "SYS_MODULE"
      override def isSysModule: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object SYS_RAWIO extends Capability {
      val value = 1017
      val index = 18
      val name = "SYS_RAWIO"
      override def isSysRawio: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object SYS_CHROOT extends Capability {
      val value = 1018
      val index = 19
      val name = "SYS_CHROOT"
      override def isSysChroot: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object SYS_PTRACE extends Capability {
      val value = 1019
      val index = 20
      val name = "SYS_PTRACE"
      override def isSysPtrace: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object SYS_PACCT extends Capability {
      val value = 1020
      val index = 21
      val name = "SYS_PACCT"
      override def isSysPacct: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object SYS_ADMIN extends Capability {
      val value = 1021
      val index = 22
      val name = "SYS_ADMIN"
      override def isSysAdmin: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object SYS_BOOT extends Capability {
      val value = 1022
      val index = 23
      val name = "SYS_BOOT"
      override def isSysBoot: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object SYS_NICE extends Capability {
      val value = 1023
      val index = 24
      val name = "SYS_NICE"
      override def isSysNice: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object SYS_RESOURCE extends Capability {
      val value = 1024
      val index = 25
      val name = "SYS_RESOURCE"
      override def isSysResource: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object SYS_TIME extends Capability {
      val value = 1025
      val index = 26
      val name = "SYS_TIME"
      override def isSysTime: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object SYS_TTY_CONFIG extends Capability {
      val value = 1026
      val index = 27
      val name = "SYS_TTY_CONFIG"
      override def isSysTtyConfig: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object MKNOD extends Capability {
      val value = 1027
      val index = 28
      val name = "MKNOD"
      override def isMknod: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object LEASE extends Capability {
      val value = 1028
      val index = 29
      val name = "LEASE"
      override def isLease: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object AUDIT_WRITE extends Capability {
      val value = 1029
      val index = 30
      val name = "AUDIT_WRITE"
      override def isAuditWrite: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object AUDIT_CONTROL extends Capability {
      val value = 1030
      val index = 31
      val name = "AUDIT_CONTROL"
      override def isAuditControl: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object SETFCAP extends Capability {
      val value = 1031
      val index = 32
      val name = "SETFCAP"
      override def isSetfcap: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object MAC_OVERRIDE extends Capability {
      val value = 1032
      val index = 33
      val name = "MAC_OVERRIDE"
      override def isMacOverride: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object MAC_ADMIN extends Capability {
      val value = 1033
      val index = 34
      val name = "MAC_ADMIN"
      override def isMacAdmin: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object SYSLOG extends Capability {
      val value = 1034
      val index = 35
      val name = "SYSLOG"
      override def isSyslog: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object WAKE_ALARM extends Capability {
      val value = 1035
      val index = 36
      val name = "WAKE_ALARM"
      override def isWakeAlarm: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object BLOCK_SUSPEND extends Capability {
      val value = 1036
      val index = 37
      val name = "BLOCK_SUSPEND"
      override def isBlockSuspend: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object AUDIT_READ extends Capability {
      val value = 1037
      val index = 38
      val name = "AUDIT_READ"
      override def isAuditRead: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case class Unrecognized(value: Int) extends Capability with _root_.com.trueaccord.scalapb.UnrecognizedEnum
    
    lazy val values = scala.collection.Seq(UNKNOWN, CHOWN, DAC_OVERRIDE, DAC_READ_SEARCH, FOWNER, FSETID, KILL, SETGID, SETUID, SETPCAP, LINUX_IMMUTABLE, NET_BIND_SERVICE, NET_BROADCAST, NET_ADMIN, NET_RAW, IPC_LOCK, IPC_OWNER, SYS_MODULE, SYS_RAWIO, SYS_CHROOT, SYS_PTRACE, SYS_PACCT, SYS_ADMIN, SYS_BOOT, SYS_NICE, SYS_RESOURCE, SYS_TIME, SYS_TTY_CONFIG, MKNOD, LEASE, AUDIT_WRITE, AUDIT_CONTROL, SETFCAP, MAC_OVERRIDE, MAC_ADMIN, SYSLOG, WAKE_ALARM, BLOCK_SUSPEND, AUDIT_READ)
    def fromValue(value: Int): Capability = value match {
      case 0 => UNKNOWN
      case 1000 => CHOWN
      case 1001 => DAC_OVERRIDE
      case 1002 => DAC_READ_SEARCH
      case 1003 => FOWNER
      case 1004 => FSETID
      case 1005 => KILL
      case 1006 => SETGID
      case 1007 => SETUID
      case 1008 => SETPCAP
      case 1009 => LINUX_IMMUTABLE
      case 1010 => NET_BIND_SERVICE
      case 1011 => NET_BROADCAST
      case 1012 => NET_ADMIN
      case 1013 => NET_RAW
      case 1014 => IPC_LOCK
      case 1015 => IPC_OWNER
      case 1016 => SYS_MODULE
      case 1017 => SYS_RAWIO
      case 1018 => SYS_CHROOT
      case 1019 => SYS_PTRACE
      case 1020 => SYS_PACCT
      case 1021 => SYS_ADMIN
      case 1022 => SYS_BOOT
      case 1023 => SYS_NICE
      case 1024 => SYS_RESOURCE
      case 1025 => SYS_TIME
      case 1026 => SYS_TTY_CONFIG
      case 1027 => MKNOD
      case 1028 => LEASE
      case 1029 => AUDIT_WRITE
      case 1030 => AUDIT_CONTROL
      case 1031 => SETFCAP
      case 1032 => MAC_OVERRIDE
      case 1033 => MAC_ADMIN
      case 1034 => SYSLOG
      case 1035 => WAKE_ALARM
      case 1036 => BLOCK_SUSPEND
      case 1037 => AUDIT_READ
      case __other => Unrecognized(__other)
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.EnumDescriptor = org.apache.mesos.v1.mesos.CapabilityInfo.javaDescriptor.getEnumTypes.get(0)
    def scalaDescriptor: _root_.scalapb.descriptors.EnumDescriptor = org.apache.mesos.v1.mesos.CapabilityInfo.scalaDescriptor.enums(0)
  }
  implicit class CapabilityInfoLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.CapabilityInfo]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, org.apache.mesos.v1.mesos.CapabilityInfo](_l) {
    def capabilities: _root_.com.trueaccord.lenses.Lens[UpperPB, _root_.scala.collection.Seq[org.apache.mesos.v1.mesos.CapabilityInfo.Capability]] = field(_.capabilities)((c_, f_) => c_.copy(capabilities = f_))
  }
  final val CAPABILITIES_FIELD_NUMBER = 1
}
