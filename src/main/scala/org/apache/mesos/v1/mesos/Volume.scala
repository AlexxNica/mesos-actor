// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO2

package org.apache.mesos.v1.mesos

/** *
  * Describes a volume mapping either from host to container or vice
  * versa. Both paths can either refer to a directory or a file.
  *
  * @param mode
  *   TODO(gyliu513): Make this as `optional` after deprecation cycle of 1.0.
  * @param containerPath
  *   Path pointing to a directory or file in the container. If the
  *   path is a relative path, it is relative to the container work
  *   directory. If the path is an absolute path, that path must
  *   already exist.
  * @param hostPath
  *   Absolute path pointing to a directory or file on the host or a
  *   path relative to the container work directory.
  * @param image
  *   The source of the volume is an Image which describes a root
  *   filesystem which will be provisioned by Mesos.
  */
@SerialVersionUID(0L)
final case class Volume(
    mode: org.apache.mesos.v1.mesos.Volume.Mode,
    containerPath: String,
    hostPath: scala.Option[String] = None,
    image: scala.Option[org.apache.mesos.v1.mesos.Image] = None,
    source: scala.Option[org.apache.mesos.v1.mesos.Volume.Source] = None
    ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Volume] with com.trueaccord.lenses.Updatable[Volume] {
    @transient
    private[this] var __serializedSizeCachedValue: Int = 0
    private[this] def __computeSerializedValue(): Int = {
      var __size = 0
      __size += _root_.com.google.protobuf.CodedOutputStream.computeEnumSize(3, mode.value)
      __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, containerPath)
      if (hostPath.isDefined) { __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(2, hostPath.get) }
      if (image.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(image.get.serializedSize) + image.get.serializedSize }
      if (source.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(source.get.serializedSize) + source.get.serializedSize }
      __size
    }
    final override def serializedSize: Int = {
      var read = __serializedSizeCachedValue
      if (read == 0) {
        read = __computeSerializedValue()
        __serializedSizeCachedValue = read
      }
      read
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
      _output__.writeString(1, containerPath)
      hostPath.foreach { __v =>
        _output__.writeString(2, __v)
      };
      _output__.writeEnum(3, mode.value)
      image.foreach { __v =>
        _output__.writeTag(4, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
      source.foreach { __v =>
        _output__.writeTag(5, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
    }
    def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): org.apache.mesos.v1.mesos.Volume = {
      var __mode = this.mode
      var __containerPath = this.containerPath
      var __hostPath = this.hostPath
      var __image = this.image
      var __source = this.source
      var __requiredFields0: Long = 0x3L
      var _done__ = false
      while (!_done__) {
        val _tag__ = _input__.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case 24 =>
            __mode = org.apache.mesos.v1.mesos.Volume.Mode.fromValue(_input__.readEnum())
            __requiredFields0 &= 0xfffffffffffffffeL
          case 10 =>
            __containerPath = _input__.readString()
            __requiredFields0 &= 0xfffffffffffffffdL
          case 18 =>
            __hostPath = Some(_input__.readString())
          case 34 =>
            __image = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __image.getOrElse(org.apache.mesos.v1.mesos.Image.defaultInstance)))
          case 42 =>
            __source = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __source.getOrElse(org.apache.mesos.v1.mesos.Volume.Source.defaultInstance)))
          case tag => _input__.skipField(tag)
        }
      }
      if (__requiredFields0 != 0L) { throw new _root_.com.google.protobuf.InvalidProtocolBufferException("Message missing required fields.") } 
      org.apache.mesos.v1.mesos.Volume(
          mode = __mode,
          containerPath = __containerPath,
          hostPath = __hostPath,
          image = __image,
          source = __source
      )
    }
    def withMode(__v: org.apache.mesos.v1.mesos.Volume.Mode): Volume = copy(mode = __v)
    def withContainerPath(__v: String): Volume = copy(containerPath = __v)
    def getHostPath: String = hostPath.getOrElse("")
    def clearHostPath: Volume = copy(hostPath = None)
    def withHostPath(__v: String): Volume = copy(hostPath = Some(__v))
    def getImage: org.apache.mesos.v1.mesos.Image = image.getOrElse(org.apache.mesos.v1.mesos.Image.defaultInstance)
    def clearImage: Volume = copy(image = None)
    def withImage(__v: org.apache.mesos.v1.mesos.Image): Volume = copy(image = Some(__v))
    def getSource: org.apache.mesos.v1.mesos.Volume.Source = source.getOrElse(org.apache.mesos.v1.mesos.Volume.Source.defaultInstance)
    def clearSource: Volume = copy(source = None)
    def withSource(__v: org.apache.mesos.v1.mesos.Volume.Source): Volume = copy(source = Some(__v))
    def getFieldByNumber(__fieldNumber: Int): scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 3 => mode.javaValueDescriptor
        case 1 => containerPath
        case 2 => hostPath.orNull
        case 4 => image.orNull
        case 5 => source.orNull
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 3 => _root_.scalapb.descriptors.PEnum(mode.scalaValueDescriptor)
        case 1 => _root_.scalapb.descriptors.PString(containerPath)
        case 2 => hostPath.map(_root_.scalapb.descriptors.PString(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 4 => image.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 5 => source.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
      }
    }
    override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
    def companion = org.apache.mesos.v1.mesos.Volume
}

object Volume extends com.trueaccord.scalapb.GeneratedMessageCompanion[org.apache.mesos.v1.mesos.Volume] {
  implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[org.apache.mesos.v1.mesos.Volume] = this
  def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): org.apache.mesos.v1.mesos.Volume = {
    require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
    val __fields = javaDescriptor.getFields
    org.apache.mesos.v1.mesos.Volume(
      org.apache.mesos.v1.mesos.Volume.Mode.fromValue(__fieldsMap(__fields.get(0)).asInstanceOf[_root_.com.google.protobuf.Descriptors.EnumValueDescriptor].getNumber),
      __fieldsMap(__fields.get(1)).asInstanceOf[String],
      __fieldsMap.get(__fields.get(2)).asInstanceOf[scala.Option[String]],
      __fieldsMap.get(__fields.get(3)).asInstanceOf[scala.Option[org.apache.mesos.v1.mesos.Image]],
      __fieldsMap.get(__fields.get(4)).asInstanceOf[scala.Option[org.apache.mesos.v1.mesos.Volume.Source]]
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[org.apache.mesos.v1.mesos.Volume] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
      org.apache.mesos.v1.mesos.Volume(
        org.apache.mesos.v1.mesos.Volume.Mode.fromValue(__fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).get.as[_root_.scalapb.descriptors.EnumValueDescriptor].number),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).get.as[String],
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[scala.Option[String]]),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(4).get).flatMap(_.as[scala.Option[org.apache.mesos.v1.mesos.Image]]),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(5).get).flatMap(_.as[scala.Option[org.apache.mesos.v1.mesos.Volume.Source]])
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = MesosProto.javaDescriptor.getMessageTypes.get(54)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = MesosProto.scalaDescriptor.messages(54)
  def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
    (__fieldNumber: @_root_.scala.unchecked) match {
      case 4 => __out = org.apache.mesos.v1.mesos.Image
      case 5 => __out = org.apache.mesos.v1.mesos.Volume.Source
    }
    __out
  }
  def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = {
    (__fieldNumber: @_root_.scala.unchecked) match {
      case 3 => org.apache.mesos.v1.mesos.Volume.Mode
    }
  }
  lazy val defaultInstance = org.apache.mesos.v1.mesos.Volume(
    mode = org.apache.mesos.v1.mesos.Volume.Mode.RW,
    containerPath = ""
  )
  sealed trait Mode extends _root_.com.trueaccord.scalapb.GeneratedEnum {
    type EnumType = Mode
    def isRw: Boolean = false
    def isRo: Boolean = false
    def companion: _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[Mode] = org.apache.mesos.v1.mesos.Volume.Mode
  }
  
  object Mode extends _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[Mode] {
    implicit def enumCompanion: _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[Mode] = this
    @SerialVersionUID(0L)
    case object RW extends Mode {
      val value = 1
      val index = 0
      val name = "RW"
      override def isRw: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object RO extends Mode {
      val value = 2
      val index = 1
      val name = "RO"
      override def isRo: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case class Unrecognized(value: Int) extends Mode with _root_.com.trueaccord.scalapb.UnrecognizedEnum
    
    lazy val values = scala.collection.Seq(RW, RO)
    def fromValue(value: Int): Mode = value match {
      case 1 => RW
      case 2 => RO
      case __other => Unrecognized(__other)
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.EnumDescriptor = org.apache.mesos.v1.mesos.Volume.javaDescriptor.getEnumTypes.get(0)
    def scalaDescriptor: _root_.scalapb.descriptors.EnumDescriptor = org.apache.mesos.v1.mesos.Volume.scalaDescriptor.enums(0)
  }
  /** Describes where a volume originates from.
    *
    * @param type
    *   Enum fields should be optional, see: MESOS-4997.
    * @param dockerVolume
    *   The source of the volume created by docker volume driver.
    * @param secret
    *   The volume/secret isolator uses the secret-fetcher module (third-party or
    *   internal) downloads the secret and makes it available at container_path.
    */
  @SerialVersionUID(0L)
  final case class Source(
      `type`: scala.Option[org.apache.mesos.v1.mesos.Volume.Source.Type] = None,
      dockerVolume: scala.Option[org.apache.mesos.v1.mesos.Volume.Source.DockerVolume] = None,
      sandboxPath: scala.Option[org.apache.mesos.v1.mesos.Volume.Source.SandboxPath] = None,
      secret: scala.Option[org.apache.mesos.v1.mesos.Secret] = None
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Source] with com.trueaccord.lenses.Updatable[Source] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        if (`type`.isDefined) { __size += _root_.com.google.protobuf.CodedOutputStream.computeEnumSize(1, `type`.get.value) }
        if (dockerVolume.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(dockerVolume.get.serializedSize) + dockerVolume.get.serializedSize }
        if (sandboxPath.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(sandboxPath.get.serializedSize) + sandboxPath.get.serializedSize }
        if (secret.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(secret.get.serializedSize) + secret.get.serializedSize }
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
        `type`.foreach { __v =>
          _output__.writeEnum(1, __v.value)
        };
        dockerVolume.foreach { __v =>
          _output__.writeTag(2, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        };
        sandboxPath.foreach { __v =>
          _output__.writeTag(3, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        };
        secret.foreach { __v =>
          _output__.writeTag(4, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        };
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): org.apache.mesos.v1.mesos.Volume.Source = {
        var __type = this.`type`
        var __dockerVolume = this.dockerVolume
        var __sandboxPath = this.sandboxPath
        var __secret = this.secret
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 8 =>
              __type = Some(org.apache.mesos.v1.mesos.Volume.Source.Type.fromValue(_input__.readEnum()))
            case 18 =>
              __dockerVolume = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __dockerVolume.getOrElse(org.apache.mesos.v1.mesos.Volume.Source.DockerVolume.defaultInstance)))
            case 26 =>
              __sandboxPath = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __sandboxPath.getOrElse(org.apache.mesos.v1.mesos.Volume.Source.SandboxPath.defaultInstance)))
            case 34 =>
              __secret = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __secret.getOrElse(org.apache.mesos.v1.mesos.Secret.defaultInstance)))
            case tag => _input__.skipField(tag)
          }
        }
        org.apache.mesos.v1.mesos.Volume.Source(
            `type` = __type,
            dockerVolume = __dockerVolume,
            sandboxPath = __sandboxPath,
            secret = __secret
        )
      }
      def getType: org.apache.mesos.v1.mesos.Volume.Source.Type = `type`.getOrElse(org.apache.mesos.v1.mesos.Volume.Source.Type.UNKNOWN)
      def clearType: Source = copy(`type` = None)
      def withType(__v: org.apache.mesos.v1.mesos.Volume.Source.Type): Source = copy(`type` = Some(__v))
      def getDockerVolume: org.apache.mesos.v1.mesos.Volume.Source.DockerVolume = dockerVolume.getOrElse(org.apache.mesos.v1.mesos.Volume.Source.DockerVolume.defaultInstance)
      def clearDockerVolume: Source = copy(dockerVolume = None)
      def withDockerVolume(__v: org.apache.mesos.v1.mesos.Volume.Source.DockerVolume): Source = copy(dockerVolume = Some(__v))
      def getSandboxPath: org.apache.mesos.v1.mesos.Volume.Source.SandboxPath = sandboxPath.getOrElse(org.apache.mesos.v1.mesos.Volume.Source.SandboxPath.defaultInstance)
      def clearSandboxPath: Source = copy(sandboxPath = None)
      def withSandboxPath(__v: org.apache.mesos.v1.mesos.Volume.Source.SandboxPath): Source = copy(sandboxPath = Some(__v))
      def getSecret: org.apache.mesos.v1.mesos.Secret = secret.getOrElse(org.apache.mesos.v1.mesos.Secret.defaultInstance)
      def clearSecret: Source = copy(secret = None)
      def withSecret(__v: org.apache.mesos.v1.mesos.Secret): Source = copy(secret = Some(__v))
      def getFieldByNumber(__fieldNumber: Int): scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => `type`.map(_.javaValueDescriptor).orNull
          case 2 => dockerVolume.orNull
          case 3 => sandboxPath.orNull
          case 4 => secret.orNull
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => `type`.map(__e => _root_.scalapb.descriptors.PEnum(__e.scalaValueDescriptor)).getOrElse(_root_.scalapb.descriptors.PEmpty)
          case 2 => dockerVolume.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
          case 3 => sandboxPath.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
          case 4 => secret.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        }
      }
      override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = org.apache.mesos.v1.mesos.Volume.Source
  }
  
  object Source extends com.trueaccord.scalapb.GeneratedMessageCompanion[org.apache.mesos.v1.mesos.Volume.Source] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[org.apache.mesos.v1.mesos.Volume.Source] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): org.apache.mesos.v1.mesos.Volume.Source = {
      require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      org.apache.mesos.v1.mesos.Volume.Source(
        __fieldsMap.get(__fields.get(0)).asInstanceOf[scala.Option[_root_.com.google.protobuf.Descriptors.EnumValueDescriptor]].map(__e => org.apache.mesos.v1.mesos.Volume.Source.Type.fromValue(__e.getNumber)),
        __fieldsMap.get(__fields.get(1)).asInstanceOf[scala.Option[org.apache.mesos.v1.mesos.Volume.Source.DockerVolume]],
        __fieldsMap.get(__fields.get(2)).asInstanceOf[scala.Option[org.apache.mesos.v1.mesos.Volume.Source.SandboxPath]],
        __fieldsMap.get(__fields.get(3)).asInstanceOf[scala.Option[org.apache.mesos.v1.mesos.Secret]]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[org.apache.mesos.v1.mesos.Volume.Source] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        org.apache.mesos.v1.mesos.Volume.Source(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).flatMap(_.as[scala.Option[_root_.scalapb.descriptors.EnumValueDescriptor]]).map(__e => org.apache.mesos.v1.mesos.Volume.Source.Type.fromValue(__e.number)),
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[scala.Option[org.apache.mesos.v1.mesos.Volume.Source.DockerVolume]]),
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).flatMap(_.as[scala.Option[org.apache.mesos.v1.mesos.Volume.Source.SandboxPath]]),
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(4).get).flatMap(_.as[scala.Option[org.apache.mesos.v1.mesos.Secret]])
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = org.apache.mesos.v1.mesos.Volume.javaDescriptor.getNestedTypes.get(0)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = org.apache.mesos.v1.mesos.Volume.scalaDescriptor.nestedMessages(0)
    def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
      var __out: _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 2 => __out = org.apache.mesos.v1.mesos.Volume.Source.DockerVolume
        case 3 => __out = org.apache.mesos.v1.mesos.Volume.Source.SandboxPath
        case 4 => __out = org.apache.mesos.v1.mesos.Secret
      }
      __out
    }
    def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => org.apache.mesos.v1.mesos.Volume.Source.Type
      }
    }
    lazy val defaultInstance = org.apache.mesos.v1.mesos.Volume.Source(
    )
    sealed trait Type extends _root_.com.trueaccord.scalapb.GeneratedEnum {
      type EnumType = Type
      def isUnknown: Boolean = false
      def isDockerVolume: Boolean = false
      def isSandboxPath: Boolean = false
      def isSecret: Boolean = false
      def companion: _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[Type] = org.apache.mesos.v1.mesos.Volume.Source.Type
    }
    
    object Type extends _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[Type] {
      implicit def enumCompanion: _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[Type] = this
      @SerialVersionUID(0L)
      case object UNKNOWN extends Type {
        val value = 0
        val index = 0
        val name = "UNKNOWN"
        override def isUnknown: Boolean = true
      }
      
      @SerialVersionUID(0L)
      case object DOCKER_VOLUME extends Type {
        val value = 1
        val index = 1
        val name = "DOCKER_VOLUME"
        override def isDockerVolume: Boolean = true
      }
      
      @SerialVersionUID(0L)
      case object SANDBOX_PATH extends Type {
        val value = 2
        val index = 2
        val name = "SANDBOX_PATH"
        override def isSandboxPath: Boolean = true
      }
      
      @SerialVersionUID(0L)
      case object SECRET extends Type {
        val value = 3
        val index = 3
        val name = "SECRET"
        override def isSecret: Boolean = true
      }
      
      @SerialVersionUID(0L)
      case class Unrecognized(value: Int) extends Type with _root_.com.trueaccord.scalapb.UnrecognizedEnum
      
      lazy val values = scala.collection.Seq(UNKNOWN, DOCKER_VOLUME, SANDBOX_PATH, SECRET)
      def fromValue(value: Int): Type = value match {
        case 0 => UNKNOWN
        case 1 => DOCKER_VOLUME
        case 2 => SANDBOX_PATH
        case 3 => SECRET
        case __other => Unrecognized(__other)
      }
      def javaDescriptor: _root_.com.google.protobuf.Descriptors.EnumDescriptor = org.apache.mesos.v1.mesos.Volume.Source.javaDescriptor.getEnumTypes.get(0)
      def scalaDescriptor: _root_.scalapb.descriptors.EnumDescriptor = org.apache.mesos.v1.mesos.Volume.Source.scalaDescriptor.enums(0)
    }
    /** @param driver
      *   Driver of the volume, it can be flocker, convoy, raxrey etc.
      * @param name
      *   Name of the volume.
      * @param driverOptions
      *   Volume driver specific options.
      */
    @SerialVersionUID(0L)
    final case class DockerVolume(
        driver: scala.Option[String] = None,
        name: String,
        driverOptions: scala.Option[org.apache.mesos.v1.mesos.Parameters] = None
        ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[DockerVolume] with com.trueaccord.lenses.Updatable[DockerVolume] {
        @transient
        private[this] var __serializedSizeCachedValue: Int = 0
        private[this] def __computeSerializedValue(): Int = {
          var __size = 0
          if (driver.isDefined) { __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, driver.get) }
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(2, name)
          if (driverOptions.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(driverOptions.get.serializedSize) + driverOptions.get.serializedSize }
          __size
        }
        final override def serializedSize: Int = {
          var read = __serializedSizeCachedValue
          if (read == 0) {
            read = __computeSerializedValue()
            __serializedSizeCachedValue = read
          }
          read
        }
        def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
          driver.foreach { __v =>
            _output__.writeString(1, __v)
          };
          _output__.writeString(2, name)
          driverOptions.foreach { __v =>
            _output__.writeTag(3, 2)
            _output__.writeUInt32NoTag(__v.serializedSize)
            __v.writeTo(_output__)
          };
        }
        def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): org.apache.mesos.v1.mesos.Volume.Source.DockerVolume = {
          var __driver = this.driver
          var __name = this.name
          var __driverOptions = this.driverOptions
          var __requiredFields0: Long = 0x1L
          var _done__ = false
          while (!_done__) {
            val _tag__ = _input__.readTag()
            _tag__ match {
              case 0 => _done__ = true
              case 10 =>
                __driver = Some(_input__.readString())
              case 18 =>
                __name = _input__.readString()
                __requiredFields0 &= 0xfffffffffffffffeL
              case 26 =>
                __driverOptions = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __driverOptions.getOrElse(org.apache.mesos.v1.mesos.Parameters.defaultInstance)))
              case tag => _input__.skipField(tag)
            }
          }
          if (__requiredFields0 != 0L) { throw new _root_.com.google.protobuf.InvalidProtocolBufferException("Message missing required fields.") } 
          org.apache.mesos.v1.mesos.Volume.Source.DockerVolume(
              driver = __driver,
              name = __name,
              driverOptions = __driverOptions
          )
        }
        def getDriver: String = driver.getOrElse("")
        def clearDriver: DockerVolume = copy(driver = None)
        def withDriver(__v: String): DockerVolume = copy(driver = Some(__v))
        def withName(__v: String): DockerVolume = copy(name = __v)
        def getDriverOptions: org.apache.mesos.v1.mesos.Parameters = driverOptions.getOrElse(org.apache.mesos.v1.mesos.Parameters.defaultInstance)
        def clearDriverOptions: DockerVolume = copy(driverOptions = None)
        def withDriverOptions(__v: org.apache.mesos.v1.mesos.Parameters): DockerVolume = copy(driverOptions = Some(__v))
        def getFieldByNumber(__fieldNumber: Int): scala.Any = {
          (__fieldNumber: @_root_.scala.unchecked) match {
            case 1 => driver.orNull
            case 2 => name
            case 3 => driverOptions.orNull
          }
        }
        def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
          require(__field.containingMessage eq companion.scalaDescriptor)
          (__field.number: @_root_.scala.unchecked) match {
            case 1 => driver.map(_root_.scalapb.descriptors.PString(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
            case 2 => _root_.scalapb.descriptors.PString(name)
            case 3 => driverOptions.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
          }
        }
        override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
        def companion = org.apache.mesos.v1.mesos.Volume.Source.DockerVolume
    }
    
    object DockerVolume extends com.trueaccord.scalapb.GeneratedMessageCompanion[org.apache.mesos.v1.mesos.Volume.Source.DockerVolume] {
      implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[org.apache.mesos.v1.mesos.Volume.Source.DockerVolume] = this
      def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): org.apache.mesos.v1.mesos.Volume.Source.DockerVolume = {
        require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
        val __fields = javaDescriptor.getFields
        org.apache.mesos.v1.mesos.Volume.Source.DockerVolume(
          __fieldsMap.get(__fields.get(0)).asInstanceOf[scala.Option[String]],
          __fieldsMap(__fields.get(1)).asInstanceOf[String],
          __fieldsMap.get(__fields.get(2)).asInstanceOf[scala.Option[org.apache.mesos.v1.mesos.Parameters]]
        )
      }
      implicit def messageReads: _root_.scalapb.descriptors.Reads[org.apache.mesos.v1.mesos.Volume.Source.DockerVolume] = _root_.scalapb.descriptors.Reads{
        case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
          require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
          org.apache.mesos.v1.mesos.Volume.Source.DockerVolume(
            __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).flatMap(_.as[scala.Option[String]]),
            __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).get.as[String],
            __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).flatMap(_.as[scala.Option[org.apache.mesos.v1.mesos.Parameters]])
          )
        case _ => throw new RuntimeException("Expected PMessage")
      }
      def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = org.apache.mesos.v1.mesos.Volume.Source.javaDescriptor.getNestedTypes.get(0)
      def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = org.apache.mesos.v1.mesos.Volume.Source.scalaDescriptor.nestedMessages(0)
      def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
        var __out: _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 3 => __out = org.apache.mesos.v1.mesos.Parameters
        }
        __out
      }
      def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
      lazy val defaultInstance = org.apache.mesos.v1.mesos.Volume.Source.DockerVolume(
        name = ""
      )
      implicit class DockerVolumeLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.Volume.Source.DockerVolume]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, org.apache.mesos.v1.mesos.Volume.Source.DockerVolume](_l) {
        def driver: _root_.com.trueaccord.lenses.Lens[UpperPB, String] = field(_.getDriver)((c_, f_) => c_.copy(driver = Some(f_)))
        def optionalDriver: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[String]] = field(_.driver)((c_, f_) => c_.copy(driver = f_))
        def name: _root_.com.trueaccord.lenses.Lens[UpperPB, String] = field(_.name)((c_, f_) => c_.copy(name = f_))
        def driverOptions: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.Parameters] = field(_.getDriverOptions)((c_, f_) => c_.copy(driverOptions = Some(f_)))
        def optionalDriverOptions: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[org.apache.mesos.v1.mesos.Parameters]] = field(_.driverOptions)((c_, f_) => c_.copy(driverOptions = f_))
      }
      final val DRIVER_FIELD_NUMBER = 1
      final val NAME_FIELD_NUMBER = 2
      final val DRIVER_OPTIONS_FIELD_NUMBER = 3
    }
    
    /** Describe a path from a container's sandbox. The container can
      * be the current container (SELF), or its parent container
      * (PARENT). PARENT allows all child containers to share a volume
      * from their parent container's sandbox. It'll be an error if
      * the current container is a top level container.
      *
      * @param path
      *   A path relative to the corresponding container's sandbox.
      *   Note that upwards traversal (i.e. ../../abc) is not allowed.
      */
    @SerialVersionUID(0L)
    final case class SandboxPath(
        `type`: scala.Option[org.apache.mesos.v1.mesos.Volume.Source.SandboxPath.Type] = None,
        path: String
        ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[SandboxPath] with com.trueaccord.lenses.Updatable[SandboxPath] {
        @transient
        private[this] var __serializedSizeCachedValue: Int = 0
        private[this] def __computeSerializedValue(): Int = {
          var __size = 0
          if (`type`.isDefined) { __size += _root_.com.google.protobuf.CodedOutputStream.computeEnumSize(1, `type`.get.value) }
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(2, path)
          __size
        }
        final override def serializedSize: Int = {
          var read = __serializedSizeCachedValue
          if (read == 0) {
            read = __computeSerializedValue()
            __serializedSizeCachedValue = read
          }
          read
        }
        def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
          `type`.foreach { __v =>
            _output__.writeEnum(1, __v.value)
          };
          _output__.writeString(2, path)
        }
        def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): org.apache.mesos.v1.mesos.Volume.Source.SandboxPath = {
          var __type = this.`type`
          var __path = this.path
          var __requiredFields0: Long = 0x1L
          var _done__ = false
          while (!_done__) {
            val _tag__ = _input__.readTag()
            _tag__ match {
              case 0 => _done__ = true
              case 8 =>
                __type = Some(org.apache.mesos.v1.mesos.Volume.Source.SandboxPath.Type.fromValue(_input__.readEnum()))
              case 18 =>
                __path = _input__.readString()
                __requiredFields0 &= 0xfffffffffffffffeL
              case tag => _input__.skipField(tag)
            }
          }
          if (__requiredFields0 != 0L) { throw new _root_.com.google.protobuf.InvalidProtocolBufferException("Message missing required fields.") } 
          org.apache.mesos.v1.mesos.Volume.Source.SandboxPath(
              `type` = __type,
              path = __path
          )
        }
        def getType: org.apache.mesos.v1.mesos.Volume.Source.SandboxPath.Type = `type`.getOrElse(org.apache.mesos.v1.mesos.Volume.Source.SandboxPath.Type.UNKNOWN)
        def clearType: SandboxPath = copy(`type` = None)
        def withType(__v: org.apache.mesos.v1.mesos.Volume.Source.SandboxPath.Type): SandboxPath = copy(`type` = Some(__v))
        def withPath(__v: String): SandboxPath = copy(path = __v)
        def getFieldByNumber(__fieldNumber: Int): scala.Any = {
          (__fieldNumber: @_root_.scala.unchecked) match {
            case 1 => `type`.map(_.javaValueDescriptor).orNull
            case 2 => path
          }
        }
        def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
          require(__field.containingMessage eq companion.scalaDescriptor)
          (__field.number: @_root_.scala.unchecked) match {
            case 1 => `type`.map(__e => _root_.scalapb.descriptors.PEnum(__e.scalaValueDescriptor)).getOrElse(_root_.scalapb.descriptors.PEmpty)
            case 2 => _root_.scalapb.descriptors.PString(path)
          }
        }
        override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
        def companion = org.apache.mesos.v1.mesos.Volume.Source.SandboxPath
    }
    
    object SandboxPath extends com.trueaccord.scalapb.GeneratedMessageCompanion[org.apache.mesos.v1.mesos.Volume.Source.SandboxPath] {
      implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[org.apache.mesos.v1.mesos.Volume.Source.SandboxPath] = this
      def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): org.apache.mesos.v1.mesos.Volume.Source.SandboxPath = {
        require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
        val __fields = javaDescriptor.getFields
        org.apache.mesos.v1.mesos.Volume.Source.SandboxPath(
          __fieldsMap.get(__fields.get(0)).asInstanceOf[scala.Option[_root_.com.google.protobuf.Descriptors.EnumValueDescriptor]].map(__e => org.apache.mesos.v1.mesos.Volume.Source.SandboxPath.Type.fromValue(__e.getNumber)),
          __fieldsMap(__fields.get(1)).asInstanceOf[String]
        )
      }
      implicit def messageReads: _root_.scalapb.descriptors.Reads[org.apache.mesos.v1.mesos.Volume.Source.SandboxPath] = _root_.scalapb.descriptors.Reads{
        case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
          require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
          org.apache.mesos.v1.mesos.Volume.Source.SandboxPath(
            __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).flatMap(_.as[scala.Option[_root_.scalapb.descriptors.EnumValueDescriptor]]).map(__e => org.apache.mesos.v1.mesos.Volume.Source.SandboxPath.Type.fromValue(__e.number)),
            __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).get.as[String]
          )
        case _ => throw new RuntimeException("Expected PMessage")
      }
      def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = org.apache.mesos.v1.mesos.Volume.Source.javaDescriptor.getNestedTypes.get(1)
      def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = org.apache.mesos.v1.mesos.Volume.Source.scalaDescriptor.nestedMessages(1)
      def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__fieldNumber)
      def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => org.apache.mesos.v1.mesos.Volume.Source.SandboxPath.Type
        }
      }
      lazy val defaultInstance = org.apache.mesos.v1.mesos.Volume.Source.SandboxPath(
        path = ""
      )
      sealed trait Type extends _root_.com.trueaccord.scalapb.GeneratedEnum {
        type EnumType = Type
        def isUnknown: Boolean = false
        def isSelf: Boolean = false
        def isParent: Boolean = false
        def companion: _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[Type] = org.apache.mesos.v1.mesos.Volume.Source.SandboxPath.Type
      }
      
      object Type extends _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[Type] {
        implicit def enumCompanion: _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[Type] = this
        @SerialVersionUID(0L)
        case object UNKNOWN extends Type {
          val value = 0
          val index = 0
          val name = "UNKNOWN"
          override def isUnknown: Boolean = true
        }
        
        @SerialVersionUID(0L)
        case object SELF extends Type {
          val value = 1
          val index = 1
          val name = "SELF"
          override def isSelf: Boolean = true
        }
        
        @SerialVersionUID(0L)
        case object PARENT extends Type {
          val value = 2
          val index = 2
          val name = "PARENT"
          override def isParent: Boolean = true
        }
        
        @SerialVersionUID(0L)
        case class Unrecognized(value: Int) extends Type with _root_.com.trueaccord.scalapb.UnrecognizedEnum
        
        lazy val values = scala.collection.Seq(UNKNOWN, SELF, PARENT)
        def fromValue(value: Int): Type = value match {
          case 0 => UNKNOWN
          case 1 => SELF
          case 2 => PARENT
          case __other => Unrecognized(__other)
        }
        def javaDescriptor: _root_.com.google.protobuf.Descriptors.EnumDescriptor = org.apache.mesos.v1.mesos.Volume.Source.SandboxPath.javaDescriptor.getEnumTypes.get(0)
        def scalaDescriptor: _root_.scalapb.descriptors.EnumDescriptor = org.apache.mesos.v1.mesos.Volume.Source.SandboxPath.scalaDescriptor.enums(0)
      }
      implicit class SandboxPathLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.Volume.Source.SandboxPath]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, org.apache.mesos.v1.mesos.Volume.Source.SandboxPath](_l) {
        def `type`: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.Volume.Source.SandboxPath.Type] = field(_.getType)((c_, f_) => c_.copy(`type` = Some(f_)))
        def optionalType: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[org.apache.mesos.v1.mesos.Volume.Source.SandboxPath.Type]] = field(_.`type`)((c_, f_) => c_.copy(`type` = f_))
        def path: _root_.com.trueaccord.lenses.Lens[UpperPB, String] = field(_.path)((c_, f_) => c_.copy(path = f_))
      }
      final val TYPE_FIELD_NUMBER = 1
      final val PATH_FIELD_NUMBER = 2
    }
    
    implicit class SourceLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.Volume.Source]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, org.apache.mesos.v1.mesos.Volume.Source](_l) {
      def `type`: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.Volume.Source.Type] = field(_.getType)((c_, f_) => c_.copy(`type` = Some(f_)))
      def optionalType: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[org.apache.mesos.v1.mesos.Volume.Source.Type]] = field(_.`type`)((c_, f_) => c_.copy(`type` = f_))
      def dockerVolume: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.Volume.Source.DockerVolume] = field(_.getDockerVolume)((c_, f_) => c_.copy(dockerVolume = Some(f_)))
      def optionalDockerVolume: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[org.apache.mesos.v1.mesos.Volume.Source.DockerVolume]] = field(_.dockerVolume)((c_, f_) => c_.copy(dockerVolume = f_))
      def sandboxPath: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.Volume.Source.SandboxPath] = field(_.getSandboxPath)((c_, f_) => c_.copy(sandboxPath = Some(f_)))
      def optionalSandboxPath: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[org.apache.mesos.v1.mesos.Volume.Source.SandboxPath]] = field(_.sandboxPath)((c_, f_) => c_.copy(sandboxPath = f_))
      def secret: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.Secret] = field(_.getSecret)((c_, f_) => c_.copy(secret = Some(f_)))
      def optionalSecret: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[org.apache.mesos.v1.mesos.Secret]] = field(_.secret)((c_, f_) => c_.copy(secret = f_))
    }
    final val TYPE_FIELD_NUMBER = 1
    final val DOCKER_VOLUME_FIELD_NUMBER = 2
    final val SANDBOX_PATH_FIELD_NUMBER = 3
    final val SECRET_FIELD_NUMBER = 4
  }
  
  implicit class VolumeLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.Volume]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, org.apache.mesos.v1.mesos.Volume](_l) {
    def mode: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.Volume.Mode] = field(_.mode)((c_, f_) => c_.copy(mode = f_))
    def containerPath: _root_.com.trueaccord.lenses.Lens[UpperPB, String] = field(_.containerPath)((c_, f_) => c_.copy(containerPath = f_))
    def hostPath: _root_.com.trueaccord.lenses.Lens[UpperPB, String] = field(_.getHostPath)((c_, f_) => c_.copy(hostPath = Some(f_)))
    def optionalHostPath: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[String]] = field(_.hostPath)((c_, f_) => c_.copy(hostPath = f_))
    def image: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.Image] = field(_.getImage)((c_, f_) => c_.copy(image = Some(f_)))
    def optionalImage: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[org.apache.mesos.v1.mesos.Image]] = field(_.image)((c_, f_) => c_.copy(image = f_))
    def source: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.Volume.Source] = field(_.getSource)((c_, f_) => c_.copy(source = Some(f_)))
    def optionalSource: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[org.apache.mesos.v1.mesos.Volume.Source]] = field(_.source)((c_, f_) => c_.copy(source = f_))
  }
  final val MODE_FIELD_NUMBER = 3
  final val CONTAINER_PATH_FIELD_NUMBER = 1
  final val HOST_PATH_FIELD_NUMBER = 2
  final val IMAGE_FIELD_NUMBER = 4
  final val SOURCE_FIELD_NUMBER = 5
}
