// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO2

package org.apache.mesos.v1.mesos

/** *
  * Describes an Attribute or Resource "value". A value is described
  * using the standard protocol buffer "union" trick.
  */
@SerialVersionUID(0L)
final case class Value(
    `type`: org.apache.mesos.v1.mesos.Value.Type,
    scalar: scala.Option[org.apache.mesos.v1.mesos.Value.Scalar] = None,
    ranges: scala.Option[org.apache.mesos.v1.mesos.Value.Ranges] = None,
    set: scala.Option[org.apache.mesos.v1.mesos.Value.Set] = None,
    text: scala.Option[org.apache.mesos.v1.mesos.Value.Text] = None
    ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Value] with com.trueaccord.lenses.Updatable[Value] {
    @transient
    private[this] var __serializedSizeCachedValue: Int = 0
    private[this] def __computeSerializedValue(): Int = {
      var __size = 0
      __size += _root_.com.google.protobuf.CodedOutputStream.computeEnumSize(1, `type`.value)
      if (scalar.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(scalar.get.serializedSize) + scalar.get.serializedSize }
      if (ranges.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(ranges.get.serializedSize) + ranges.get.serializedSize }
      if (set.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(set.get.serializedSize) + set.get.serializedSize }
      if (text.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(text.get.serializedSize) + text.get.serializedSize }
      __size
    }
    final override def serializedSize: Int = {
      var read = __serializedSizeCachedValue
      if (read == 0) {
        read = __computeSerializedValue()
        __serializedSizeCachedValue = read
      }
      read
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
      _output__.writeEnum(1, `type`.value)
      scalar.foreach { __v =>
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
      ranges.foreach { __v =>
        _output__.writeTag(3, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
      set.foreach { __v =>
        _output__.writeTag(4, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
      text.foreach { __v =>
        _output__.writeTag(5, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
    }
    def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): org.apache.mesos.v1.mesos.Value = {
      var __type = this.`type`
      var __scalar = this.scalar
      var __ranges = this.ranges
      var __set = this.set
      var __text = this.text
      var __requiredFields0: Long = 0x1L
      var _done__ = false
      while (!_done__) {
        val _tag__ = _input__.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case 8 =>
            __type = org.apache.mesos.v1.mesos.Value.Type.fromValue(_input__.readEnum())
            __requiredFields0 &= 0xfffffffffffffffeL
          case 18 =>
            __scalar = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __scalar.getOrElse(org.apache.mesos.v1.mesos.Value.Scalar.defaultInstance)))
          case 26 =>
            __ranges = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __ranges.getOrElse(org.apache.mesos.v1.mesos.Value.Ranges.defaultInstance)))
          case 34 =>
            __set = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __set.getOrElse(org.apache.mesos.v1.mesos.Value.Set.defaultInstance)))
          case 42 =>
            __text = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __text.getOrElse(org.apache.mesos.v1.mesos.Value.Text.defaultInstance)))
          case tag => _input__.skipField(tag)
        }
      }
      if (__requiredFields0 != 0L) { throw new _root_.com.google.protobuf.InvalidProtocolBufferException("Message missing required fields.") } 
      org.apache.mesos.v1.mesos.Value(
          `type` = __type,
          scalar = __scalar,
          ranges = __ranges,
          set = __set,
          text = __text
      )
    }
    def withType(__v: org.apache.mesos.v1.mesos.Value.Type): Value = copy(`type` = __v)
    def getScalar: org.apache.mesos.v1.mesos.Value.Scalar = scalar.getOrElse(org.apache.mesos.v1.mesos.Value.Scalar.defaultInstance)
    def clearScalar: Value = copy(scalar = None)
    def withScalar(__v: org.apache.mesos.v1.mesos.Value.Scalar): Value = copy(scalar = Some(__v))
    def getRanges: org.apache.mesos.v1.mesos.Value.Ranges = ranges.getOrElse(org.apache.mesos.v1.mesos.Value.Ranges.defaultInstance)
    def clearRanges: Value = copy(ranges = None)
    def withRanges(__v: org.apache.mesos.v1.mesos.Value.Ranges): Value = copy(ranges = Some(__v))
    def getSet: org.apache.mesos.v1.mesos.Value.Set = set.getOrElse(org.apache.mesos.v1.mesos.Value.Set.defaultInstance)
    def clearSet: Value = copy(set = None)
    def withSet(__v: org.apache.mesos.v1.mesos.Value.Set): Value = copy(set = Some(__v))
    def getText: org.apache.mesos.v1.mesos.Value.Text = text.getOrElse(org.apache.mesos.v1.mesos.Value.Text.defaultInstance)
    def clearText: Value = copy(text = None)
    def withText(__v: org.apache.mesos.v1.mesos.Value.Text): Value = copy(text = Some(__v))
    def getFieldByNumber(__fieldNumber: Int): scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => `type`.javaValueDescriptor
        case 2 => scalar.orNull
        case 3 => ranges.orNull
        case 4 => set.orNull
        case 5 => text.orNull
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PEnum(`type`.scalaValueDescriptor)
        case 2 => scalar.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 3 => ranges.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 4 => set.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 5 => text.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
      }
    }
    override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
    def companion = org.apache.mesos.v1.mesos.Value
}

object Value extends com.trueaccord.scalapb.GeneratedMessageCompanion[org.apache.mesos.v1.mesos.Value] {
  implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[org.apache.mesos.v1.mesos.Value] = this
  def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): org.apache.mesos.v1.mesos.Value = {
    require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
    val __fields = javaDescriptor.getFields
    org.apache.mesos.v1.mesos.Value(
      org.apache.mesos.v1.mesos.Value.Type.fromValue(__fieldsMap(__fields.get(0)).asInstanceOf[_root_.com.google.protobuf.Descriptors.EnumValueDescriptor].getNumber),
      __fieldsMap.get(__fields.get(1)).asInstanceOf[scala.Option[org.apache.mesos.v1.mesos.Value.Scalar]],
      __fieldsMap.get(__fields.get(2)).asInstanceOf[scala.Option[org.apache.mesos.v1.mesos.Value.Ranges]],
      __fieldsMap.get(__fields.get(3)).asInstanceOf[scala.Option[org.apache.mesos.v1.mesos.Value.Set]],
      __fieldsMap.get(__fields.get(4)).asInstanceOf[scala.Option[org.apache.mesos.v1.mesos.Value.Text]]
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[org.apache.mesos.v1.mesos.Value] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
      org.apache.mesos.v1.mesos.Value(
        org.apache.mesos.v1.mesos.Value.Type.fromValue(__fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).get.as[_root_.scalapb.descriptors.EnumValueDescriptor].number),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[scala.Option[org.apache.mesos.v1.mesos.Value.Scalar]]),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).flatMap(_.as[scala.Option[org.apache.mesos.v1.mesos.Value.Ranges]]),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(4).get).flatMap(_.as[scala.Option[org.apache.mesos.v1.mesos.Value.Set]]),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(5).get).flatMap(_.as[scala.Option[org.apache.mesos.v1.mesos.Value.Text]])
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = MesosProto.javaDescriptor.getMessageTypes.get(23)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = MesosProto.scalaDescriptor.messages(23)
  def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
    (__fieldNumber: @_root_.scala.unchecked) match {
      case 2 => __out = org.apache.mesos.v1.mesos.Value.Scalar
      case 3 => __out = org.apache.mesos.v1.mesos.Value.Ranges
      case 4 => __out = org.apache.mesos.v1.mesos.Value.Set
      case 5 => __out = org.apache.mesos.v1.mesos.Value.Text
    }
    __out
  }
  def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = {
    (__fieldNumber: @_root_.scala.unchecked) match {
      case 1 => org.apache.mesos.v1.mesos.Value.Type
    }
  }
  lazy val defaultInstance = org.apache.mesos.v1.mesos.Value(
    `type` = org.apache.mesos.v1.mesos.Value.Type.SCALAR
  )
  sealed trait Type extends _root_.com.trueaccord.scalapb.GeneratedEnum {
    type EnumType = Type
    def isScalar: Boolean = false
    def isRanges: Boolean = false
    def isSet: Boolean = false
    def isText: Boolean = false
    def companion: _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[Type] = org.apache.mesos.v1.mesos.Value.Type
  }
  
  object Type extends _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[Type] {
    implicit def enumCompanion: _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[Type] = this
    @SerialVersionUID(0L)
    case object SCALAR extends Type {
      val value = 0
      val index = 0
      val name = "SCALAR"
      override def isScalar: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object RANGES extends Type {
      val value = 1
      val index = 1
      val name = "RANGES"
      override def isRanges: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object SET extends Type {
      val value = 2
      val index = 2
      val name = "SET"
      override def isSet: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object TEXT extends Type {
      val value = 3
      val index = 3
      val name = "TEXT"
      override def isText: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case class Unrecognized(value: Int) extends Type with _root_.com.trueaccord.scalapb.UnrecognizedEnum
    
    lazy val values = scala.collection.Seq(SCALAR, RANGES, SET, TEXT)
    def fromValue(value: Int): Type = value match {
      case 0 => SCALAR
      case 1 => RANGES
      case 2 => SET
      case 3 => TEXT
      case __other => Unrecognized(__other)
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.EnumDescriptor = org.apache.mesos.v1.mesos.Value.javaDescriptor.getEnumTypes.get(0)
    def scalaDescriptor: _root_.scalapb.descriptors.EnumDescriptor = org.apache.mesos.v1.mesos.Value.scalaDescriptor.enums(0)
  }
  /** @param value
    *   Scalar values are represented using floating point. To reduce
    *   the chance of unpredictable floating point behavior due to
    *   roundoff error, Mesos only supports three decimal digits of
    *   precision for scalar resource values. That is, floating point
    *   values are converted to a fixed point format that supports
    *   three decimal digits of precision, and then converted back to
    *   floating point on output. Any additional precision in scalar
    *   resource values is discarded (via rounding).
    */
  @SerialVersionUID(0L)
  final case class Scalar(
      value: Double
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Scalar] with com.trueaccord.lenses.Updatable[Scalar] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        __size += _root_.com.google.protobuf.CodedOutputStream.computeDoubleSize(1, value)
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
        _output__.writeDouble(1, value)
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): org.apache.mesos.v1.mesos.Value.Scalar = {
        var __value = this.value
        var __requiredFields0: Long = 0x1L
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 9 =>
              __value = _input__.readDouble()
              __requiredFields0 &= 0xfffffffffffffffeL
            case tag => _input__.skipField(tag)
          }
        }
        if (__requiredFields0 != 0L) { throw new _root_.com.google.protobuf.InvalidProtocolBufferException("Message missing required fields.") } 
        org.apache.mesos.v1.mesos.Value.Scalar(
            value = __value
        )
      }
      def withValue(__v: Double): Scalar = copy(value = __v)
      def getFieldByNumber(__fieldNumber: Int): scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => value
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => _root_.scalapb.descriptors.PDouble(value)
        }
      }
      override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = org.apache.mesos.v1.mesos.Value.Scalar
  }
  
  object Scalar extends com.trueaccord.scalapb.GeneratedMessageCompanion[org.apache.mesos.v1.mesos.Value.Scalar] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[org.apache.mesos.v1.mesos.Value.Scalar] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): org.apache.mesos.v1.mesos.Value.Scalar = {
      require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      org.apache.mesos.v1.mesos.Value.Scalar(
        __fieldsMap(__fields.get(0)).asInstanceOf[Double]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[org.apache.mesos.v1.mesos.Value.Scalar] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        org.apache.mesos.v1.mesos.Value.Scalar(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).get.as[Double]
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = org.apache.mesos.v1.mesos.Value.javaDescriptor.getNestedTypes.get(0)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = org.apache.mesos.v1.mesos.Value.scalaDescriptor.nestedMessages(0)
    def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__fieldNumber)
    def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = org.apache.mesos.v1.mesos.Value.Scalar(
      value = 0.0
    )
    implicit class ScalarLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.Value.Scalar]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, org.apache.mesos.v1.mesos.Value.Scalar](_l) {
      def value: _root_.com.trueaccord.lenses.Lens[UpperPB, Double] = field(_.value)((c_, f_) => c_.copy(value = f_))
    }
    final val VALUE_FIELD_NUMBER = 1
  }
  
  @SerialVersionUID(0L)
  final case class Range(
      begin: Long,
      end: Long
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Range] with com.trueaccord.lenses.Updatable[Range] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt64Size(1, begin)
        __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt64Size(2, end)
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
        _output__.writeUInt64(1, begin)
        _output__.writeUInt64(2, end)
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): org.apache.mesos.v1.mesos.Value.Range = {
        var __begin = this.begin
        var __end = this.end
        var __requiredFields0: Long = 0x3L
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 8 =>
              __begin = _input__.readUInt64()
              __requiredFields0 &= 0xfffffffffffffffeL
            case 16 =>
              __end = _input__.readUInt64()
              __requiredFields0 &= 0xfffffffffffffffdL
            case tag => _input__.skipField(tag)
          }
        }
        if (__requiredFields0 != 0L) { throw new _root_.com.google.protobuf.InvalidProtocolBufferException("Message missing required fields.") } 
        org.apache.mesos.v1.mesos.Value.Range(
            begin = __begin,
            end = __end
        )
      }
      def withBegin(__v: Long): Range = copy(begin = __v)
      def withEnd(__v: Long): Range = copy(end = __v)
      def getFieldByNumber(__fieldNumber: Int): scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => begin
          case 2 => end
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => _root_.scalapb.descriptors.PLong(begin)
          case 2 => _root_.scalapb.descriptors.PLong(end)
        }
      }
      override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = org.apache.mesos.v1.mesos.Value.Range
  }
  
  object Range extends com.trueaccord.scalapb.GeneratedMessageCompanion[org.apache.mesos.v1.mesos.Value.Range] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[org.apache.mesos.v1.mesos.Value.Range] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): org.apache.mesos.v1.mesos.Value.Range = {
      require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      org.apache.mesos.v1.mesos.Value.Range(
        __fieldsMap(__fields.get(0)).asInstanceOf[Long],
        __fieldsMap(__fields.get(1)).asInstanceOf[Long]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[org.apache.mesos.v1.mesos.Value.Range] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        org.apache.mesos.v1.mesos.Value.Range(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).get.as[Long],
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).get.as[Long]
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = org.apache.mesos.v1.mesos.Value.javaDescriptor.getNestedTypes.get(1)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = org.apache.mesos.v1.mesos.Value.scalaDescriptor.nestedMessages(1)
    def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__fieldNumber)
    def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = org.apache.mesos.v1.mesos.Value.Range(
      begin = 0L,
      end = 0L
    )
    implicit class RangeLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.Value.Range]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, org.apache.mesos.v1.mesos.Value.Range](_l) {
      def begin: _root_.com.trueaccord.lenses.Lens[UpperPB, Long] = field(_.begin)((c_, f_) => c_.copy(begin = f_))
      def end: _root_.com.trueaccord.lenses.Lens[UpperPB, Long] = field(_.end)((c_, f_) => c_.copy(end = f_))
    }
    final val BEGIN_FIELD_NUMBER = 1
    final val END_FIELD_NUMBER = 2
  }
  
  @SerialVersionUID(0L)
  final case class Ranges(
      range: _root_.scala.collection.Seq[org.apache.mesos.v1.mesos.Value.Range] = _root_.scala.collection.Seq.empty
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Ranges] with com.trueaccord.lenses.Updatable[Ranges] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        range.foreach(range => __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(range.serializedSize) + range.serializedSize)
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
        range.foreach { __v =>
          _output__.writeTag(1, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        };
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): org.apache.mesos.v1.mesos.Value.Ranges = {
        val __range = (_root_.scala.collection.immutable.Vector.newBuilder[org.apache.mesos.v1.mesos.Value.Range] ++= this.range)
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __range += _root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, org.apache.mesos.v1.mesos.Value.Range.defaultInstance)
            case tag => _input__.skipField(tag)
          }
        }
        org.apache.mesos.v1.mesos.Value.Ranges(
            range = __range.result()
        )
      }
      def clearRange = copy(range = _root_.scala.collection.Seq.empty)
      def addRange(__vs: org.apache.mesos.v1.mesos.Value.Range*): Ranges = addAllRange(__vs)
      def addAllRange(__vs: TraversableOnce[org.apache.mesos.v1.mesos.Value.Range]): Ranges = copy(range = range ++ __vs)
      def withRange(__v: _root_.scala.collection.Seq[org.apache.mesos.v1.mesos.Value.Range]): Ranges = copy(range = __v)
      def getFieldByNumber(__fieldNumber: Int): scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => range
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => _root_.scalapb.descriptors.PRepeated(range.map(_.toPMessage)(_root_.scala.collection.breakOut))
        }
      }
      override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = org.apache.mesos.v1.mesos.Value.Ranges
  }
  
  object Ranges extends com.trueaccord.scalapb.GeneratedMessageCompanion[org.apache.mesos.v1.mesos.Value.Ranges] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[org.apache.mesos.v1.mesos.Value.Ranges] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): org.apache.mesos.v1.mesos.Value.Ranges = {
      require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      org.apache.mesos.v1.mesos.Value.Ranges(
        __fieldsMap.getOrElse(__fields.get(0), Nil).asInstanceOf[_root_.scala.collection.Seq[org.apache.mesos.v1.mesos.Value.Range]]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[org.apache.mesos.v1.mesos.Value.Ranges] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        org.apache.mesos.v1.mesos.Value.Ranges(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.collection.Seq[org.apache.mesos.v1.mesos.Value.Range]]).getOrElse(_root_.scala.collection.Seq.empty)
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = org.apache.mesos.v1.mesos.Value.javaDescriptor.getNestedTypes.get(2)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = org.apache.mesos.v1.mesos.Value.scalaDescriptor.nestedMessages(2)
    def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
      var __out: _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => __out = org.apache.mesos.v1.mesos.Value.Range
      }
      __out
    }
    def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = org.apache.mesos.v1.mesos.Value.Ranges(
    )
    implicit class RangesLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.Value.Ranges]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, org.apache.mesos.v1.mesos.Value.Ranges](_l) {
      def range: _root_.com.trueaccord.lenses.Lens[UpperPB, _root_.scala.collection.Seq[org.apache.mesos.v1.mesos.Value.Range]] = field(_.range)((c_, f_) => c_.copy(range = f_))
    }
    final val RANGE_FIELD_NUMBER = 1
  }
  
  @SerialVersionUID(0L)
  final case class Set(
      item: _root_.scala.collection.Seq[String] = _root_.scala.collection.Seq.empty
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Set] with com.trueaccord.lenses.Updatable[Set] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        item.foreach(item => __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, item))
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
        item.foreach { __v =>
          _output__.writeString(1, __v)
        };
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): org.apache.mesos.v1.mesos.Value.Set = {
        val __item = (_root_.scala.collection.immutable.Vector.newBuilder[String] ++= this.item)
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __item += _input__.readString()
            case tag => _input__.skipField(tag)
          }
        }
        org.apache.mesos.v1.mesos.Value.Set(
            item = __item.result()
        )
      }
      def clearItem = copy(item = _root_.scala.collection.Seq.empty)
      def addItem(__vs: String*): Set = addAllItem(__vs)
      def addAllItem(__vs: TraversableOnce[String]): Set = copy(item = item ++ __vs)
      def withItem(__v: _root_.scala.collection.Seq[String]): Set = copy(item = __v)
      def getFieldByNumber(__fieldNumber: Int): scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => item
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => _root_.scalapb.descriptors.PRepeated(item.map(_root_.scalapb.descriptors.PString(_))(_root_.scala.collection.breakOut))
        }
      }
      override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = org.apache.mesos.v1.mesos.Value.Set
  }
  
  object Set extends com.trueaccord.scalapb.GeneratedMessageCompanion[org.apache.mesos.v1.mesos.Value.Set] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[org.apache.mesos.v1.mesos.Value.Set] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): org.apache.mesos.v1.mesos.Value.Set = {
      require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      org.apache.mesos.v1.mesos.Value.Set(
        __fieldsMap.getOrElse(__fields.get(0), Nil).asInstanceOf[_root_.scala.collection.Seq[String]]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[org.apache.mesos.v1.mesos.Value.Set] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        org.apache.mesos.v1.mesos.Value.Set(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.collection.Seq[String]]).getOrElse(_root_.scala.collection.Seq.empty)
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = org.apache.mesos.v1.mesos.Value.javaDescriptor.getNestedTypes.get(3)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = org.apache.mesos.v1.mesos.Value.scalaDescriptor.nestedMessages(3)
    def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__fieldNumber)
    def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = org.apache.mesos.v1.mesos.Value.Set(
    )
    implicit class SetLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.Value.Set]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, org.apache.mesos.v1.mesos.Value.Set](_l) {
      def item: _root_.com.trueaccord.lenses.Lens[UpperPB, _root_.scala.collection.Seq[String]] = field(_.item)((c_, f_) => c_.copy(item = f_))
    }
    final val ITEM_FIELD_NUMBER = 1
  }
  
  @SerialVersionUID(0L)
  final case class Text(
      value: String
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Text] with com.trueaccord.lenses.Updatable[Text] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, value)
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
        _output__.writeString(1, value)
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): org.apache.mesos.v1.mesos.Value.Text = {
        var __value = this.value
        var __requiredFields0: Long = 0x1L
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __value = _input__.readString()
              __requiredFields0 &= 0xfffffffffffffffeL
            case tag => _input__.skipField(tag)
          }
        }
        if (__requiredFields0 != 0L) { throw new _root_.com.google.protobuf.InvalidProtocolBufferException("Message missing required fields.") } 
        org.apache.mesos.v1.mesos.Value.Text(
            value = __value
        )
      }
      def withValue(__v: String): Text = copy(value = __v)
      def getFieldByNumber(__fieldNumber: Int): scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => value
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => _root_.scalapb.descriptors.PString(value)
        }
      }
      override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = org.apache.mesos.v1.mesos.Value.Text
  }
  
  object Text extends com.trueaccord.scalapb.GeneratedMessageCompanion[org.apache.mesos.v1.mesos.Value.Text] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[org.apache.mesos.v1.mesos.Value.Text] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): org.apache.mesos.v1.mesos.Value.Text = {
      require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      org.apache.mesos.v1.mesos.Value.Text(
        __fieldsMap(__fields.get(0)).asInstanceOf[String]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[org.apache.mesos.v1.mesos.Value.Text] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        org.apache.mesos.v1.mesos.Value.Text(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).get.as[String]
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = org.apache.mesos.v1.mesos.Value.javaDescriptor.getNestedTypes.get(4)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = org.apache.mesos.v1.mesos.Value.scalaDescriptor.nestedMessages(4)
    def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__fieldNumber)
    def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = org.apache.mesos.v1.mesos.Value.Text(
      value = ""
    )
    implicit class TextLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.Value.Text]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, org.apache.mesos.v1.mesos.Value.Text](_l) {
      def value: _root_.com.trueaccord.lenses.Lens[UpperPB, String] = field(_.value)((c_, f_) => c_.copy(value = f_))
    }
    final val VALUE_FIELD_NUMBER = 1
  }
  
  implicit class ValueLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.Value]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, org.apache.mesos.v1.mesos.Value](_l) {
    def `type`: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.Value.Type] = field(_.`type`)((c_, f_) => c_.copy(`type` = f_))
    def scalar: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.Value.Scalar] = field(_.getScalar)((c_, f_) => c_.copy(scalar = Some(f_)))
    def optionalScalar: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[org.apache.mesos.v1.mesos.Value.Scalar]] = field(_.scalar)((c_, f_) => c_.copy(scalar = f_))
    def ranges: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.Value.Ranges] = field(_.getRanges)((c_, f_) => c_.copy(ranges = Some(f_)))
    def optionalRanges: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[org.apache.mesos.v1.mesos.Value.Ranges]] = field(_.ranges)((c_, f_) => c_.copy(ranges = f_))
    def set: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.Value.Set] = field(_.getSet)((c_, f_) => c_.copy(set = Some(f_)))
    def optionalSet: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[org.apache.mesos.v1.mesos.Value.Set]] = field(_.set)((c_, f_) => c_.copy(set = f_))
    def text: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.Value.Text] = field(_.getText)((c_, f_) => c_.copy(text = Some(f_)))
    def optionalText: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[org.apache.mesos.v1.mesos.Value.Text]] = field(_.text)((c_, f_) => c_.copy(text = f_))
  }
  final val TYPE_FIELD_NUMBER = 1
  final val SCALAR_FIELD_NUMBER = 2
  final val RANGES_FIELD_NUMBER = 3
  final val SET_FIELD_NUMBER = 4
  final val TEXT_FIELD_NUMBER = 5
}
