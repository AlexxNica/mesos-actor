// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO2

package org.apache.mesos.v1.master

import org.apache.mesos.v1.maintenance.Schedule
import org.apache.mesos.v1.{maintenance, master, quota}
import org.apache.mesos.v1.quota.QuotaRequest

/** *
  * Calls that can be sent to the v1 master API.
  *
  * A call is described using the standard protocol buffer "union"
  * trick, see
  * https://developers.google.com/protocol-buffers/docs/techniques#union.
  */
@SerialVersionUID(0L)
final case class Call(
                       `type`: scala.Option[Call.Type] = None,
                       getMetrics: scala.Option[Call.GetMetrics] = None,
                       setLoggingLevel: scala.Option[Call.SetLoggingLevel] = None,
                       listFiles: scala.Option[Call.ListFiles] = None,
                       readFile: scala.Option[Call.ReadFile] = None,
                       updateWeights: scala.Option[Call.UpdateWeights] = None,
                       reserveResources: scala.Option[Call.ReserveResources] = None,
                       unreserveResources: scala.Option[Call.UnreserveResources] = None,
                       createVolumes: scala.Option[Call.CreateVolumes] = None,
                       destroyVolumes: scala.Option[Call.DestroyVolumes] = None,
                       updateMaintenanceSchedule: scala.Option[Call.UpdateMaintenanceSchedule] = None,
                       startMaintenance: scala.Option[Call.StartMaintenance] = None,
                       stopMaintenance: scala.Option[Call.StopMaintenance] = None,
                       setQuota: scala.Option[Call.SetQuota] = None,
                       removeQuota: scala.Option[Call.RemoveQuota] = None
    ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Call] with com.trueaccord.lenses.Updatable[Call] {
    @transient
    private[this] var __serializedSizeCachedValue: Int = 0
    private[this] def __computeSerializedValue(): Int = {
      var __size = 0
      if (`type`.isDefined) { __size += _root_.com.google.protobuf.CodedOutputStream.computeEnumSize(1, `type`.get.value) }
      if (getMetrics.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(getMetrics.get.serializedSize) + getMetrics.get.serializedSize }
      if (setLoggingLevel.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(setLoggingLevel.get.serializedSize) + setLoggingLevel.get.serializedSize }
      if (listFiles.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(listFiles.get.serializedSize) + listFiles.get.serializedSize }
      if (readFile.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(readFile.get.serializedSize) + readFile.get.serializedSize }
      if (updateWeights.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(updateWeights.get.serializedSize) + updateWeights.get.serializedSize }
      if (reserveResources.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(reserveResources.get.serializedSize) + reserveResources.get.serializedSize }
      if (unreserveResources.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(unreserveResources.get.serializedSize) + unreserveResources.get.serializedSize }
      if (createVolumes.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(createVolumes.get.serializedSize) + createVolumes.get.serializedSize }
      if (destroyVolumes.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(destroyVolumes.get.serializedSize) + destroyVolumes.get.serializedSize }
      if (updateMaintenanceSchedule.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(updateMaintenanceSchedule.get.serializedSize) + updateMaintenanceSchedule.get.serializedSize }
      if (startMaintenance.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(startMaintenance.get.serializedSize) + startMaintenance.get.serializedSize }
      if (stopMaintenance.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(stopMaintenance.get.serializedSize) + stopMaintenance.get.serializedSize }
      if (setQuota.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(setQuota.get.serializedSize) + setQuota.get.serializedSize }
      if (removeQuota.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(removeQuota.get.serializedSize) + removeQuota.get.serializedSize }
      __size
    }
    final override def serializedSize: Int = {
      var read = __serializedSizeCachedValue
      if (read == 0) {
        read = __computeSerializedValue()
        __serializedSizeCachedValue = read
      }
      read
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
      `type`.foreach { __v =>
        _output__.writeEnum(1, __v.value)
      };
      getMetrics.foreach { __v =>
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
      setLoggingLevel.foreach { __v =>
        _output__.writeTag(3, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
      listFiles.foreach { __v =>
        _output__.writeTag(4, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
      readFile.foreach { __v =>
        _output__.writeTag(5, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
      updateWeights.foreach { __v =>
        _output__.writeTag(6, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
      reserveResources.foreach { __v =>
        _output__.writeTag(7, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
      unreserveResources.foreach { __v =>
        _output__.writeTag(8, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
      createVolumes.foreach { __v =>
        _output__.writeTag(9, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
      destroyVolumes.foreach { __v =>
        _output__.writeTag(10, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
      updateMaintenanceSchedule.foreach { __v =>
        _output__.writeTag(11, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
      startMaintenance.foreach { __v =>
        _output__.writeTag(12, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
      stopMaintenance.foreach { __v =>
        _output__.writeTag(13, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
      setQuota.foreach { __v =>
        _output__.writeTag(14, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
      removeQuota.foreach { __v =>
        _output__.writeTag(15, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
    }
    def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): Call = {
      var __type = this.`type`
      var __getMetrics = this.getMetrics
      var __setLoggingLevel = this.setLoggingLevel
      var __listFiles = this.listFiles
      var __readFile = this.readFile
      var __updateWeights = this.updateWeights
      var __reserveResources = this.reserveResources
      var __unreserveResources = this.unreserveResources
      var __createVolumes = this.createVolumes
      var __destroyVolumes = this.destroyVolumes
      var __updateMaintenanceSchedule = this.updateMaintenanceSchedule
      var __startMaintenance = this.startMaintenance
      var __stopMaintenance = this.stopMaintenance
      var __setQuota = this.setQuota
      var __removeQuota = this.removeQuota
      var _done__ = false
      while (!_done__) {
        val _tag__ = _input__.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case 8 =>
            __type = Some(master.Call.Type.fromValue(_input__.readEnum()))
          case 18 =>
            __getMetrics = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __getMetrics.getOrElse(master.Call.GetMetrics.defaultInstance)))
          case 26 =>
            __setLoggingLevel = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __setLoggingLevel.getOrElse(master.Call.SetLoggingLevel.defaultInstance)))
          case 34 =>
            __listFiles = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __listFiles.getOrElse(master.Call.ListFiles.defaultInstance)))
          case 42 =>
            __readFile = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __readFile.getOrElse(master.Call.ReadFile.defaultInstance)))
          case 50 =>
            __updateWeights = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __updateWeights.getOrElse(master.Call.UpdateWeights.defaultInstance)))
          case 58 =>
            __reserveResources = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __reserveResources.getOrElse(master.Call.ReserveResources.defaultInstance)))
          case 66 =>
            __unreserveResources = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __unreserveResources.getOrElse(master.Call.UnreserveResources.defaultInstance)))
          case 74 =>
            __createVolumes = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __createVolumes.getOrElse(master.Call.CreateVolumes.defaultInstance)))
          case 82 =>
            __destroyVolumes = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __destroyVolumes.getOrElse(master.Call.DestroyVolumes.defaultInstance)))
          case 90 =>
            __updateMaintenanceSchedule = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __updateMaintenanceSchedule.getOrElse(master.Call.UpdateMaintenanceSchedule.defaultInstance)))
          case 98 =>
            __startMaintenance = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __startMaintenance.getOrElse(master.Call.StartMaintenance.defaultInstance)))
          case 106 =>
            __stopMaintenance = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __stopMaintenance.getOrElse(master.Call.StopMaintenance.defaultInstance)))
          case 114 =>
            __setQuota = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __setQuota.getOrElse(master.Call.SetQuota.defaultInstance)))
          case 122 =>
            __removeQuota = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __removeQuota.getOrElse(master.Call.RemoveQuota.defaultInstance)))
          case tag => _input__.skipField(tag)
        }
      }
      master.Call(
          `type` = __type,
          getMetrics = __getMetrics,
          setLoggingLevel = __setLoggingLevel,
          listFiles = __listFiles,
          readFile = __readFile,
          updateWeights = __updateWeights,
          reserveResources = __reserveResources,
          unreserveResources = __unreserveResources,
          createVolumes = __createVolumes,
          destroyVolumes = __destroyVolumes,
          updateMaintenanceSchedule = __updateMaintenanceSchedule,
          startMaintenance = __startMaintenance,
          stopMaintenance = __stopMaintenance,
          setQuota = __setQuota,
          removeQuota = __removeQuota
      )
    }
    def getType: Call.Type = `type`.getOrElse(master.Call.Type.UNKNOWN)
    def clearType: Call = copy(`type` = None)
    def withType(__v: Call.Type): Call = copy(`type` = Some(__v))
    def getGetMetrics: Call.GetMetrics = getMetrics.getOrElse(master.Call.GetMetrics.defaultInstance)
    def clearGetMetrics: Call = copy(getMetrics = None)
    def withGetMetrics(__v: Call.GetMetrics): Call = copy(getMetrics = Some(__v))
    def getSetLoggingLevel: Call.SetLoggingLevel = setLoggingLevel.getOrElse(master.Call.SetLoggingLevel.defaultInstance)
    def clearSetLoggingLevel: Call = copy(setLoggingLevel = None)
    def withSetLoggingLevel(__v: Call.SetLoggingLevel): Call = copy(setLoggingLevel = Some(__v))
    def getListFiles: Call.ListFiles = listFiles.getOrElse(master.Call.ListFiles.defaultInstance)
    def clearListFiles: Call = copy(listFiles = None)
    def withListFiles(__v: Call.ListFiles): Call = copy(listFiles = Some(__v))
    def getReadFile: Call.ReadFile = readFile.getOrElse(master.Call.ReadFile.defaultInstance)
    def clearReadFile: Call = copy(readFile = None)
    def withReadFile(__v: Call.ReadFile): Call = copy(readFile = Some(__v))
    def getUpdateWeights: Call.UpdateWeights = updateWeights.getOrElse(master.Call.UpdateWeights.defaultInstance)
    def clearUpdateWeights: Call = copy(updateWeights = None)
    def withUpdateWeights(__v: Call.UpdateWeights): Call = copy(updateWeights = Some(__v))
    def getReserveResources: Call.ReserveResources = reserveResources.getOrElse(master.Call.ReserveResources.defaultInstance)
    def clearReserveResources: Call = copy(reserveResources = None)
    def withReserveResources(__v: Call.ReserveResources): Call = copy(reserveResources = Some(__v))
    def getUnreserveResources: Call.UnreserveResources = unreserveResources.getOrElse(master.Call.UnreserveResources.defaultInstance)
    def clearUnreserveResources: Call = copy(unreserveResources = None)
    def withUnreserveResources(__v: Call.UnreserveResources): Call = copy(unreserveResources = Some(__v))
    def getCreateVolumes: Call.CreateVolumes = createVolumes.getOrElse(master.Call.CreateVolumes.defaultInstance)
    def clearCreateVolumes: Call = copy(createVolumes = None)
    def withCreateVolumes(__v: Call.CreateVolumes): Call = copy(createVolumes = Some(__v))
    def getDestroyVolumes: Call.DestroyVolumes = destroyVolumes.getOrElse(master.Call.DestroyVolumes.defaultInstance)
    def clearDestroyVolumes: Call = copy(destroyVolumes = None)
    def withDestroyVolumes(__v: Call.DestroyVolumes): Call = copy(destroyVolumes = Some(__v))
    def getUpdateMaintenanceSchedule: Call.UpdateMaintenanceSchedule = updateMaintenanceSchedule.getOrElse(master.Call.UpdateMaintenanceSchedule.defaultInstance)
    def clearUpdateMaintenanceSchedule: Call = copy(updateMaintenanceSchedule = None)
    def withUpdateMaintenanceSchedule(__v: Call.UpdateMaintenanceSchedule): Call = copy(updateMaintenanceSchedule = Some(__v))
    def getStartMaintenance: Call.StartMaintenance = startMaintenance.getOrElse(master.Call.StartMaintenance.defaultInstance)
    def clearStartMaintenance: Call = copy(startMaintenance = None)
    def withStartMaintenance(__v: Call.StartMaintenance): Call = copy(startMaintenance = Some(__v))
    def getStopMaintenance: Call.StopMaintenance = stopMaintenance.getOrElse(master.Call.StopMaintenance.defaultInstance)
    def clearStopMaintenance: Call = copy(stopMaintenance = None)
    def withStopMaintenance(__v: Call.StopMaintenance): Call = copy(stopMaintenance = Some(__v))
    def getSetQuota: Call.SetQuota = setQuota.getOrElse(master.Call.SetQuota.defaultInstance)
    def clearSetQuota: Call = copy(setQuota = None)
    def withSetQuota(__v: Call.SetQuota): Call = copy(setQuota = Some(__v))
    def getRemoveQuota: Call.RemoveQuota = removeQuota.getOrElse(master.Call.RemoveQuota.defaultInstance)
    def clearRemoveQuota: Call = copy(removeQuota = None)
    def withRemoveQuota(__v: Call.RemoveQuota): Call = copy(removeQuota = Some(__v))
    def getFieldByNumber(__fieldNumber: Int): scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => `type`.map(_.javaValueDescriptor).orNull
        case 2 => getMetrics.orNull
        case 3 => setLoggingLevel.orNull
        case 4 => listFiles.orNull
        case 5 => readFile.orNull
        case 6 => updateWeights.orNull
        case 7 => reserveResources.orNull
        case 8 => unreserveResources.orNull
        case 9 => createVolumes.orNull
        case 10 => destroyVolumes.orNull
        case 11 => updateMaintenanceSchedule.orNull
        case 12 => startMaintenance.orNull
        case 13 => stopMaintenance.orNull
        case 14 => setQuota.orNull
        case 15 => removeQuota.orNull
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => `type`.map(__e => _root_.scalapb.descriptors.PEnum(__e.scalaValueDescriptor)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 2 => getMetrics.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 3 => setLoggingLevel.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 4 => listFiles.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 5 => readFile.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 6 => updateWeights.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 7 => reserveResources.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 8 => unreserveResources.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 9 => createVolumes.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 10 => destroyVolumes.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 11 => updateMaintenanceSchedule.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 12 => startMaintenance.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 13 => stopMaintenance.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 14 => setQuota.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 15 => removeQuota.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
      }
    }
    override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
    def companion = master.Call
}

object Call extends com.trueaccord.scalapb.GeneratedMessageCompanion[Call] {
  implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Call] = this
  def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): Call = {
    require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
    val __fields = javaDescriptor.getFields
    master.Call(
      __fieldsMap.get(__fields.get(0)).asInstanceOf[scala.Option[_root_.com.google.protobuf.Descriptors.EnumValueDescriptor]].map(__e => master.Call.Type.fromValue(__e.getNumber)),
      __fieldsMap.get(__fields.get(1)).asInstanceOf[scala.Option[Call.GetMetrics]],
      __fieldsMap.get(__fields.get(2)).asInstanceOf[scala.Option[Call.SetLoggingLevel]],
      __fieldsMap.get(__fields.get(3)).asInstanceOf[scala.Option[Call.ListFiles]],
      __fieldsMap.get(__fields.get(4)).asInstanceOf[scala.Option[Call.ReadFile]],
      __fieldsMap.get(__fields.get(5)).asInstanceOf[scala.Option[Call.UpdateWeights]],
      __fieldsMap.get(__fields.get(6)).asInstanceOf[scala.Option[Call.ReserveResources]],
      __fieldsMap.get(__fields.get(7)).asInstanceOf[scala.Option[Call.UnreserveResources]],
      __fieldsMap.get(__fields.get(8)).asInstanceOf[scala.Option[Call.CreateVolumes]],
      __fieldsMap.get(__fields.get(9)).asInstanceOf[scala.Option[Call.DestroyVolumes]],
      __fieldsMap.get(__fields.get(10)).asInstanceOf[scala.Option[Call.UpdateMaintenanceSchedule]],
      __fieldsMap.get(__fields.get(11)).asInstanceOf[scala.Option[Call.StartMaintenance]],
      __fieldsMap.get(__fields.get(12)).asInstanceOf[scala.Option[Call.StopMaintenance]],
      __fieldsMap.get(__fields.get(13)).asInstanceOf[scala.Option[Call.SetQuota]],
      __fieldsMap.get(__fields.get(14)).asInstanceOf[scala.Option[Call.RemoveQuota]]
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[Call] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
      master.Call(
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).flatMap(_.as[scala.Option[_root_.scalapb.descriptors.EnumValueDescriptor]]).map(__e => master.Call.Type.fromValue(__e.number)),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[scala.Option[Call.GetMetrics]]),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).flatMap(_.as[scala.Option[Call.SetLoggingLevel]]),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(4).get).flatMap(_.as[scala.Option[Call.ListFiles]]),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(5).get).flatMap(_.as[scala.Option[Call.ReadFile]]),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(6).get).flatMap(_.as[scala.Option[Call.UpdateWeights]]),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(7).get).flatMap(_.as[scala.Option[Call.ReserveResources]]),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(8).get).flatMap(_.as[scala.Option[Call.UnreserveResources]]),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(9).get).flatMap(_.as[scala.Option[Call.CreateVolumes]]),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(10).get).flatMap(_.as[scala.Option[Call.DestroyVolumes]]),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(11).get).flatMap(_.as[scala.Option[Call.UpdateMaintenanceSchedule]]),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(12).get).flatMap(_.as[scala.Option[Call.StartMaintenance]]),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(13).get).flatMap(_.as[scala.Option[Call.StopMaintenance]]),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(14).get).flatMap(_.as[scala.Option[Call.SetQuota]]),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(15).get).flatMap(_.as[scala.Option[Call.RemoveQuota]])
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = MasterProto.javaDescriptor.getMessageTypes.get(0)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = MasterProto.scalaDescriptor.messages(0)
  def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
    (__fieldNumber: @_root_.scala.unchecked) match {
      case 2 => __out = master.Call.GetMetrics
      case 3 => __out = master.Call.SetLoggingLevel
      case 4 => __out = master.Call.ListFiles
      case 5 => __out = master.Call.ReadFile
      case 6 => __out = master.Call.UpdateWeights
      case 7 => __out = master.Call.ReserveResources
      case 8 => __out = master.Call.UnreserveResources
      case 9 => __out = master.Call.CreateVolumes
      case 10 => __out = master.Call.DestroyVolumes
      case 11 => __out = master.Call.UpdateMaintenanceSchedule
      case 12 => __out = master.Call.StartMaintenance
      case 13 => __out = master.Call.StopMaintenance
      case 14 => __out = master.Call.SetQuota
      case 15 => __out = master.Call.RemoveQuota
    }
    __out
  }
  def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = {
    (__fieldNumber: @_root_.scala.unchecked) match {
      case 1 => master.Call.Type
    }
  }
  lazy val defaultInstance = master.Call(
  )
  sealed trait Type extends _root_.com.trueaccord.scalapb.GeneratedEnum {
    type EnumType = Type
    def isUnknown: Boolean = false
    def isGetHealth: Boolean = false
    def isGetFlags: Boolean = false
    def isGetVersion: Boolean = false
    def isGetMetrics: Boolean = false
    def isGetLoggingLevel: Boolean = false
    def isSetLoggingLevel: Boolean = false
    def isListFiles: Boolean = false
    def isReadFile: Boolean = false
    def isGetState: Boolean = false
    def isGetAgents: Boolean = false
    def isGetFrameworks: Boolean = false
    def isGetExecutors: Boolean = false
    def isGetTasks: Boolean = false
    def isGetRoles: Boolean = false
    def isGetWeights: Boolean = false
    def isUpdateWeights: Boolean = false
    def isGetMaster: Boolean = false
    def isSubscribe: Boolean = false
    def isReserveResources: Boolean = false
    def isUnreserveResources: Boolean = false
    def isCreateVolumes: Boolean = false
    def isDestroyVolumes: Boolean = false
    def isGetMaintenanceStatus: Boolean = false
    def isGetMaintenanceSchedule: Boolean = false
    def isUpdateMaintenanceSchedule: Boolean = false
    def isStartMaintenance: Boolean = false
    def isStopMaintenance: Boolean = false
    def isGetQuota: Boolean = false
    def isSetQuota: Boolean = false
    def isRemoveQuota: Boolean = false
    def companion: _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[Type] = master.Call.Type
  }
  
  object Type extends _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[Type] {
    implicit def enumCompanion: _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[Type] = this
    @SerialVersionUID(0L)
    case object UNKNOWN extends Type {
      val value = 0
      val index = 0
      val name = "UNKNOWN"
      override def isUnknown: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object GET_HEALTH extends Type {
      val value = 1
      val index = 1
      val name = "GET_HEALTH"
      override def isGetHealth: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object GET_FLAGS extends Type {
      val value = 2
      val index = 2
      val name = "GET_FLAGS"
      override def isGetFlags: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object GET_VERSION extends Type {
      val value = 3
      val index = 3
      val name = "GET_VERSION"
      override def isGetVersion: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object GET_METRICS extends Type {
      val value = 4
      val index = 4
      val name = "GET_METRICS"
      override def isGetMetrics: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object GET_LOGGING_LEVEL extends Type {
      val value = 5
      val index = 5
      val name = "GET_LOGGING_LEVEL"
      override def isGetLoggingLevel: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object SET_LOGGING_LEVEL extends Type {
      val value = 6
      val index = 6
      val name = "SET_LOGGING_LEVEL"
      override def isSetLoggingLevel: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object LIST_FILES extends Type {
      val value = 7
      val index = 7
      val name = "LIST_FILES"
      override def isListFiles: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object READ_FILE extends Type {
      val value = 8
      val index = 8
      val name = "READ_FILE"
      override def isReadFile: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object GET_STATE extends Type {
      val value = 9
      val index = 9
      val name = "GET_STATE"
      override def isGetState: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object GET_AGENTS extends Type {
      val value = 10
      val index = 10
      val name = "GET_AGENTS"
      override def isGetAgents: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object GET_FRAMEWORKS extends Type {
      val value = 11
      val index = 11
      val name = "GET_FRAMEWORKS"
      override def isGetFrameworks: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object GET_EXECUTORS extends Type {
      val value = 12
      val index = 12
      val name = "GET_EXECUTORS"
      override def isGetExecutors: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object GET_TASKS extends Type {
      val value = 13
      val index = 13
      val name = "GET_TASKS"
      override def isGetTasks: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object GET_ROLES extends Type {
      val value = 14
      val index = 14
      val name = "GET_ROLES"
      override def isGetRoles: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object GET_WEIGHTS extends Type {
      val value = 15
      val index = 15
      val name = "GET_WEIGHTS"
      override def isGetWeights: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object UPDATE_WEIGHTS extends Type {
      val value = 16
      val index = 16
      val name = "UPDATE_WEIGHTS"
      override def isUpdateWeights: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object GET_MASTER extends Type {
      val value = 17
      val index = 17
      val name = "GET_MASTER"
      override def isGetMaster: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object SUBSCRIBE extends Type {
      val value = 18
      val index = 18
      val name = "SUBSCRIBE"
      override def isSubscribe: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object RESERVE_RESOURCES extends Type {
      val value = 19
      val index = 19
      val name = "RESERVE_RESOURCES"
      override def isReserveResources: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object UNRESERVE_RESOURCES extends Type {
      val value = 20
      val index = 20
      val name = "UNRESERVE_RESOURCES"
      override def isUnreserveResources: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object CREATE_VOLUMES extends Type {
      val value = 21
      val index = 21
      val name = "CREATE_VOLUMES"
      override def isCreateVolumes: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object DESTROY_VOLUMES extends Type {
      val value = 22
      val index = 22
      val name = "DESTROY_VOLUMES"
      override def isDestroyVolumes: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object GET_MAINTENANCE_STATUS extends Type {
      val value = 23
      val index = 23
      val name = "GET_MAINTENANCE_STATUS"
      override def isGetMaintenanceStatus: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object GET_MAINTENANCE_SCHEDULE extends Type {
      val value = 24
      val index = 24
      val name = "GET_MAINTENANCE_SCHEDULE"
      override def isGetMaintenanceSchedule: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object UPDATE_MAINTENANCE_SCHEDULE extends Type {
      val value = 25
      val index = 25
      val name = "UPDATE_MAINTENANCE_SCHEDULE"
      override def isUpdateMaintenanceSchedule: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object START_MAINTENANCE extends Type {
      val value = 26
      val index = 26
      val name = "START_MAINTENANCE"
      override def isStartMaintenance: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object STOP_MAINTENANCE extends Type {
      val value = 27
      val index = 27
      val name = "STOP_MAINTENANCE"
      override def isStopMaintenance: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object GET_QUOTA extends Type {
      val value = 28
      val index = 28
      val name = "GET_QUOTA"
      override def isGetQuota: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object SET_QUOTA extends Type {
      val value = 29
      val index = 29
      val name = "SET_QUOTA"
      override def isSetQuota: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object REMOVE_QUOTA extends Type {
      val value = 30
      val index = 30
      val name = "REMOVE_QUOTA"
      override def isRemoveQuota: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case class Unrecognized(value: Int) extends Type with _root_.com.trueaccord.scalapb.UnrecognizedEnum
    
    lazy val values = scala.collection.Seq(UNKNOWN, GET_HEALTH, GET_FLAGS, GET_VERSION, GET_METRICS, GET_LOGGING_LEVEL, SET_LOGGING_LEVEL, LIST_FILES, READ_FILE, GET_STATE, GET_AGENTS, GET_FRAMEWORKS, GET_EXECUTORS, GET_TASKS, GET_ROLES, GET_WEIGHTS, UPDATE_WEIGHTS, GET_MASTER, SUBSCRIBE, RESERVE_RESOURCES, UNRESERVE_RESOURCES, CREATE_VOLUMES, DESTROY_VOLUMES, GET_MAINTENANCE_STATUS, GET_MAINTENANCE_SCHEDULE, UPDATE_MAINTENANCE_SCHEDULE, START_MAINTENANCE, STOP_MAINTENANCE, GET_QUOTA, SET_QUOTA, REMOVE_QUOTA)
    def fromValue(value: Int): Type = value match {
      case 0 => UNKNOWN
      case 1 => GET_HEALTH
      case 2 => GET_FLAGS
      case 3 => GET_VERSION
      case 4 => GET_METRICS
      case 5 => GET_LOGGING_LEVEL
      case 6 => SET_LOGGING_LEVEL
      case 7 => LIST_FILES
      case 8 => READ_FILE
      case 9 => GET_STATE
      case 10 => GET_AGENTS
      case 11 => GET_FRAMEWORKS
      case 12 => GET_EXECUTORS
      case 13 => GET_TASKS
      case 14 => GET_ROLES
      case 15 => GET_WEIGHTS
      case 16 => UPDATE_WEIGHTS
      case 17 => GET_MASTER
      case 18 => SUBSCRIBE
      case 19 => RESERVE_RESOURCES
      case 20 => UNRESERVE_RESOURCES
      case 21 => CREATE_VOLUMES
      case 22 => DESTROY_VOLUMES
      case 23 => GET_MAINTENANCE_STATUS
      case 24 => GET_MAINTENANCE_SCHEDULE
      case 25 => UPDATE_MAINTENANCE_SCHEDULE
      case 26 => START_MAINTENANCE
      case 27 => STOP_MAINTENANCE
      case 28 => GET_QUOTA
      case 29 => SET_QUOTA
      case 30 => REMOVE_QUOTA
      case __other => Unrecognized(__other)
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.EnumDescriptor = master.Call.javaDescriptor.getEnumTypes.get(0)
    def scalaDescriptor: _root_.scalapb.descriptors.EnumDescriptor = master.Call.scalaDescriptor.enums(0)
  }
  /** Provides a snapshot of the current metrics tracked by the master.
    *
    * @param timeout
    *   If set, `timeout` would be used to determines the maximum amount of time
    *   the API will take to respond. If the timeout is exceeded, some metrics
    *   may not be included in the response.
    */
  @SerialVersionUID(0L)
  final case class GetMetrics(
      timeout: scala.Option[org.apache.mesos.v1.mesos.DurationInfo] = None
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[GetMetrics] with com.trueaccord.lenses.Updatable[GetMetrics] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        if (timeout.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(timeout.get.serializedSize) + timeout.get.serializedSize }
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
        timeout.foreach { __v =>
          _output__.writeTag(1, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        };
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): Call.GetMetrics = {
        var __timeout = this.timeout
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __timeout = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __timeout.getOrElse(org.apache.mesos.v1.mesos.DurationInfo.defaultInstance)))
            case tag => _input__.skipField(tag)
          }
        }
        master.Call.GetMetrics(
            timeout = __timeout
        )
      }
      def getTimeout: org.apache.mesos.v1.mesos.DurationInfo = timeout.getOrElse(org.apache.mesos.v1.mesos.DurationInfo.defaultInstance)
      def clearTimeout: GetMetrics = copy(timeout = None)
      def withTimeout(__v: org.apache.mesos.v1.mesos.DurationInfo): GetMetrics = copy(timeout = Some(__v))
      def getFieldByNumber(__fieldNumber: Int): scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => timeout.orNull
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => timeout.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        }
      }
      override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = master.Call.GetMetrics
  }
  
  object GetMetrics extends com.trueaccord.scalapb.GeneratedMessageCompanion[Call.GetMetrics] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Call.GetMetrics] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): Call.GetMetrics = {
      require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      master.Call.GetMetrics(
        __fieldsMap.get(__fields.get(0)).asInstanceOf[scala.Option[org.apache.mesos.v1.mesos.DurationInfo]]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[Call.GetMetrics] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        master.Call.GetMetrics(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).flatMap(_.as[scala.Option[org.apache.mesos.v1.mesos.DurationInfo]])
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = master.Call.javaDescriptor.getNestedTypes.get(0)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = master.Call.scalaDescriptor.nestedMessages(0)
    def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
      var __out: _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => __out = org.apache.mesos.v1.mesos.DurationInfo
      }
      __out
    }
    def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = master.Call.GetMetrics(
    )
    implicit class GetMetricsLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.GetMetrics]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, Call.GetMetrics](_l) {
      def timeout: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.DurationInfo] = field(_.getTimeout)((c_, f_) => c_.copy(timeout = Some(f_)))
      def optionalTimeout: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[org.apache.mesos.v1.mesos.DurationInfo]] = field(_.timeout)((c_, f_) => c_.copy(timeout = f_))
    }
    final val TIMEOUT_FIELD_NUMBER = 1
  }
  
  /** Sets the logging verbosity level for a specified duration. Mesos uses
    * [glog](https://github.com/google/glog) for logging. The library only uses
    * verbose logging which means nothing will be output unless the verbosity
    * level is set (by default it's 0, libprocess uses levels 1, 2, and 3).
    *
    * @param level
    *   The verbosity level.
    * @param duration
    *   The duration to keep verbosity level toggled. After this duration, the
    *   verbosity level of log would revert to the original level.
    */
  @SerialVersionUID(0L)
  final case class SetLoggingLevel(
      level: Int,
      duration: org.apache.mesos.v1.mesos.DurationInfo
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[SetLoggingLevel] with com.trueaccord.lenses.Updatable[SetLoggingLevel] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt32Size(1, level)
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(duration.serializedSize) + duration.serializedSize
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
        _output__.writeUInt32(1, level)
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(duration.serializedSize)
        duration.writeTo(_output__)
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): Call.SetLoggingLevel = {
        var __level = this.level
        var __duration = this.duration
        var __requiredFields0: Long = 0x3L
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 8 =>
              __level = _input__.readUInt32()
              __requiredFields0 &= 0xfffffffffffffffeL
            case 18 =>
              __duration = _root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __duration)
              __requiredFields0 &= 0xfffffffffffffffdL
            case tag => _input__.skipField(tag)
          }
        }
        if (__requiredFields0 != 0L) { throw new _root_.com.google.protobuf.InvalidProtocolBufferException("Message missing required fields.") } 
        master.Call.SetLoggingLevel(
            level = __level,
            duration = __duration
        )
      }
      def withLevel(__v: Int): SetLoggingLevel = copy(level = __v)
      def withDuration(__v: org.apache.mesos.v1.mesos.DurationInfo): SetLoggingLevel = copy(duration = __v)
      def getFieldByNumber(__fieldNumber: Int): scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => level
          case 2 => duration
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => _root_.scalapb.descriptors.PInt(level)
          case 2 => duration.toPMessage
        }
      }
      override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = master.Call.SetLoggingLevel
  }
  
  object SetLoggingLevel extends com.trueaccord.scalapb.GeneratedMessageCompanion[Call.SetLoggingLevel] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Call.SetLoggingLevel] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): Call.SetLoggingLevel = {
      require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      master.Call.SetLoggingLevel(
        __fieldsMap(__fields.get(0)).asInstanceOf[Int],
        __fieldsMap(__fields.get(1)).asInstanceOf[org.apache.mesos.v1.mesos.DurationInfo]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[Call.SetLoggingLevel] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        master.Call.SetLoggingLevel(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).get.as[Int],
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).get.as[org.apache.mesos.v1.mesos.DurationInfo]
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = master.Call.javaDescriptor.getNestedTypes.get(1)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = master.Call.scalaDescriptor.nestedMessages(1)
    def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
      var __out: _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 2 => __out = org.apache.mesos.v1.mesos.DurationInfo
      }
      __out
    }
    def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = master.Call.SetLoggingLevel(
      level = 0,
      duration = org.apache.mesos.v1.mesos.DurationInfo.defaultInstance
    )
    implicit class SetLoggingLevelLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.SetLoggingLevel]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, Call.SetLoggingLevel](_l) {
      def level: _root_.com.trueaccord.lenses.Lens[UpperPB, Int] = field(_.level)((c_, f_) => c_.copy(level = f_))
      def duration: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.DurationInfo] = field(_.duration)((c_, f_) => c_.copy(duration = f_))
    }
    final val LEVEL_FIELD_NUMBER = 1
    final val DURATION_FIELD_NUMBER = 2
  }
  
  /** Provides the file listing for a directory.
    */
  @SerialVersionUID(0L)
  final case class ListFiles(
      path: String
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[ListFiles] with com.trueaccord.lenses.Updatable[ListFiles] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, path)
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
        _output__.writeString(1, path)
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): Call.ListFiles = {
        var __path = this.path
        var __requiredFields0: Long = 0x1L
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __path = _input__.readString()
              __requiredFields0 &= 0xfffffffffffffffeL
            case tag => _input__.skipField(tag)
          }
        }
        if (__requiredFields0 != 0L) { throw new _root_.com.google.protobuf.InvalidProtocolBufferException("Message missing required fields.") } 
        master.Call.ListFiles(
            path = __path
        )
      }
      def withPath(__v: String): ListFiles = copy(path = __v)
      def getFieldByNumber(__fieldNumber: Int): scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => path
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => _root_.scalapb.descriptors.PString(path)
        }
      }
      override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = master.Call.ListFiles
  }
  
  object ListFiles extends com.trueaccord.scalapb.GeneratedMessageCompanion[Call.ListFiles] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Call.ListFiles] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): Call.ListFiles = {
      require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      master.Call.ListFiles(
        __fieldsMap(__fields.get(0)).asInstanceOf[String]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[Call.ListFiles] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        master.Call.ListFiles(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).get.as[String]
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = master.Call.javaDescriptor.getNestedTypes.get(2)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = master.Call.scalaDescriptor.nestedMessages(2)
    def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__fieldNumber)
    def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = master.Call.ListFiles(
      path = ""
    )
    implicit class ListFilesLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.ListFiles]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, Call.ListFiles](_l) {
      def path: _root_.com.trueaccord.lenses.Lens[UpperPB, String] = field(_.path)((c_, f_) => c_.copy(path = f_))
    }
    final val PATH_FIELD_NUMBER = 1
  }
  
  /** Reads data from a file.
    *
    * @param path
    *   The path of file.
    * @param offset
    *   Initial offset in file to start reading from.
    * @param length
    *   The maximum number of bytes to read. The read length is capped at 16
    *   memory pages.
    */
  @SerialVersionUID(0L)
  final case class ReadFile(
      path: String,
      offset: Long,
      length: scala.Option[Long] = None
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[ReadFile] with com.trueaccord.lenses.Updatable[ReadFile] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, path)
        __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt64Size(2, offset)
        if (length.isDefined) { __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt64Size(3, length.get) }
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
        _output__.writeString(1, path)
        _output__.writeUInt64(2, offset)
        length.foreach { __v =>
          _output__.writeUInt64(3, __v)
        };
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): Call.ReadFile = {
        var __path = this.path
        var __offset = this.offset
        var __length = this.length
        var __requiredFields0: Long = 0x3L
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __path = _input__.readString()
              __requiredFields0 &= 0xfffffffffffffffeL
            case 16 =>
              __offset = _input__.readUInt64()
              __requiredFields0 &= 0xfffffffffffffffdL
            case 24 =>
              __length = Some(_input__.readUInt64())
            case tag => _input__.skipField(tag)
          }
        }
        if (__requiredFields0 != 0L) { throw new _root_.com.google.protobuf.InvalidProtocolBufferException("Message missing required fields.") } 
        master.Call.ReadFile(
            path = __path,
            offset = __offset,
            length = __length
        )
      }
      def withPath(__v: String): ReadFile = copy(path = __v)
      def withOffset(__v: Long): ReadFile = copy(offset = __v)
      def getLength: Long = length.getOrElse(0L)
      def clearLength: ReadFile = copy(length = None)
      def withLength(__v: Long): ReadFile = copy(length = Some(__v))
      def getFieldByNumber(__fieldNumber: Int): scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => path
          case 2 => offset
          case 3 => length.orNull
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => _root_.scalapb.descriptors.PString(path)
          case 2 => _root_.scalapb.descriptors.PLong(offset)
          case 3 => length.map(_root_.scalapb.descriptors.PLong(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        }
      }
      override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = master.Call.ReadFile
  }
  
  object ReadFile extends com.trueaccord.scalapb.GeneratedMessageCompanion[Call.ReadFile] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Call.ReadFile] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): Call.ReadFile = {
      require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      master.Call.ReadFile(
        __fieldsMap(__fields.get(0)).asInstanceOf[String],
        __fieldsMap(__fields.get(1)).asInstanceOf[Long],
        __fieldsMap.get(__fields.get(2)).asInstanceOf[scala.Option[Long]]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[Call.ReadFile] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        master.Call.ReadFile(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).get.as[String],
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).get.as[Long],
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).flatMap(_.as[scala.Option[Long]])
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = master.Call.javaDescriptor.getNestedTypes.get(3)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = master.Call.scalaDescriptor.nestedMessages(3)
    def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__fieldNumber)
    def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = master.Call.ReadFile(
      path = "",
      offset = 0L
    )
    implicit class ReadFileLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.ReadFile]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, Call.ReadFile](_l) {
      def path: _root_.com.trueaccord.lenses.Lens[UpperPB, String] = field(_.path)((c_, f_) => c_.copy(path = f_))
      def offset: _root_.com.trueaccord.lenses.Lens[UpperPB, Long] = field(_.offset)((c_, f_) => c_.copy(offset = f_))
      def length: _root_.com.trueaccord.lenses.Lens[UpperPB, Long] = field(_.getLength)((c_, f_) => c_.copy(length = Some(f_)))
      def optionalLength: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Long]] = field(_.length)((c_, f_) => c_.copy(length = f_))
    }
    final val PATH_FIELD_NUMBER = 1
    final val OFFSET_FIELD_NUMBER = 2
    final val LENGTH_FIELD_NUMBER = 3
  }
  
  @SerialVersionUID(0L)
  final case class UpdateWeights(
      weightInfos: _root_.scala.collection.Seq[org.apache.mesos.v1.mesos.WeightInfo] = _root_.scala.collection.Seq.empty
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[UpdateWeights] with com.trueaccord.lenses.Updatable[UpdateWeights] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        weightInfos.foreach(weightInfos => __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(weightInfos.serializedSize) + weightInfos.serializedSize)
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
        weightInfos.foreach { __v =>
          _output__.writeTag(1, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        };
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): Call.UpdateWeights = {
        val __weightInfos = (_root_.scala.collection.immutable.Vector.newBuilder[org.apache.mesos.v1.mesos.WeightInfo] ++= this.weightInfos)
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __weightInfos += _root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, org.apache.mesos.v1.mesos.WeightInfo.defaultInstance)
            case tag => _input__.skipField(tag)
          }
        }
        master.Call.UpdateWeights(
            weightInfos = __weightInfos.result()
        )
      }
      def clearWeightInfos = copy(weightInfos = _root_.scala.collection.Seq.empty)
      def addWeightInfos(__vs: org.apache.mesos.v1.mesos.WeightInfo*): UpdateWeights = addAllWeightInfos(__vs)
      def addAllWeightInfos(__vs: TraversableOnce[org.apache.mesos.v1.mesos.WeightInfo]): UpdateWeights = copy(weightInfos = weightInfos ++ __vs)
      def withWeightInfos(__v: _root_.scala.collection.Seq[org.apache.mesos.v1.mesos.WeightInfo]): UpdateWeights = copy(weightInfos = __v)
      def getFieldByNumber(__fieldNumber: Int): scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => weightInfos
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => _root_.scalapb.descriptors.PRepeated(weightInfos.map(_.toPMessage)(_root_.scala.collection.breakOut))
        }
      }
      override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = master.Call.UpdateWeights
  }
  
  object UpdateWeights extends com.trueaccord.scalapb.GeneratedMessageCompanion[Call.UpdateWeights] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Call.UpdateWeights] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): Call.UpdateWeights = {
      require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      master.Call.UpdateWeights(
        __fieldsMap.getOrElse(__fields.get(0), Nil).asInstanceOf[_root_.scala.collection.Seq[org.apache.mesos.v1.mesos.WeightInfo]]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[Call.UpdateWeights] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        master.Call.UpdateWeights(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.collection.Seq[org.apache.mesos.v1.mesos.WeightInfo]]).getOrElse(_root_.scala.collection.Seq.empty)
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = master.Call.javaDescriptor.getNestedTypes.get(4)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = master.Call.scalaDescriptor.nestedMessages(4)
    def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
      var __out: _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => __out = org.apache.mesos.v1.mesos.WeightInfo
      }
      __out
    }
    def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = master.Call.UpdateWeights(
    )
    implicit class UpdateWeightsLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.UpdateWeights]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, Call.UpdateWeights](_l) {
      def weightInfos: _root_.com.trueaccord.lenses.Lens[UpperPB, _root_.scala.collection.Seq[org.apache.mesos.v1.mesos.WeightInfo]] = field(_.weightInfos)((c_, f_) => c_.copy(weightInfos = f_))
    }
    final val WEIGHT_INFOS_FIELD_NUMBER = 1
  }
  
  /** Reserve resources dynamically on a specific agent.
    */
  @SerialVersionUID(0L)
  final case class ReserveResources(
      agentId: org.apache.mesos.v1.mesos.AgentID,
      resources: _root_.scala.collection.Seq[org.apache.mesos.v1.mesos.Resource] = _root_.scala.collection.Seq.empty
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[ReserveResources] with com.trueaccord.lenses.Updatable[ReserveResources] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(agentId.serializedSize) + agentId.serializedSize
        resources.foreach(resources => __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(resources.serializedSize) + resources.serializedSize)
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(agentId.serializedSize)
        agentId.writeTo(_output__)
        resources.foreach { __v =>
          _output__.writeTag(2, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        };
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): Call.ReserveResources = {
        var __agentId = this.agentId
        val __resources = (_root_.scala.collection.immutable.Vector.newBuilder[org.apache.mesos.v1.mesos.Resource] ++= this.resources)
        var __requiredFields0: Long = 0x1L
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __agentId = _root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __agentId)
              __requiredFields0 &= 0xfffffffffffffffeL
            case 18 =>
              __resources += _root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, org.apache.mesos.v1.mesos.Resource.defaultInstance)
            case tag => _input__.skipField(tag)
          }
        }
        if (__requiredFields0 != 0L) { throw new _root_.com.google.protobuf.InvalidProtocolBufferException("Message missing required fields.") } 
        master.Call.ReserveResources(
            agentId = __agentId,
            resources = __resources.result()
        )
      }
      def withAgentId(__v: org.apache.mesos.v1.mesos.AgentID): ReserveResources = copy(agentId = __v)
      def clearResources = copy(resources = _root_.scala.collection.Seq.empty)
      def addResources(__vs: org.apache.mesos.v1.mesos.Resource*): ReserveResources = addAllResources(__vs)
      def addAllResources(__vs: TraversableOnce[org.apache.mesos.v1.mesos.Resource]): ReserveResources = copy(resources = resources ++ __vs)
      def withResources(__v: _root_.scala.collection.Seq[org.apache.mesos.v1.mesos.Resource]): ReserveResources = copy(resources = __v)
      def getFieldByNumber(__fieldNumber: Int): scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => agentId
          case 2 => resources
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => agentId.toPMessage
          case 2 => _root_.scalapb.descriptors.PRepeated(resources.map(_.toPMessage)(_root_.scala.collection.breakOut))
        }
      }
      override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = master.Call.ReserveResources
  }
  
  object ReserveResources extends com.trueaccord.scalapb.GeneratedMessageCompanion[Call.ReserveResources] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Call.ReserveResources] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): Call.ReserveResources = {
      require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      master.Call.ReserveResources(
        __fieldsMap(__fields.get(0)).asInstanceOf[org.apache.mesos.v1.mesos.AgentID],
        __fieldsMap.getOrElse(__fields.get(1), Nil).asInstanceOf[_root_.scala.collection.Seq[org.apache.mesos.v1.mesos.Resource]]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[Call.ReserveResources] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        master.Call.ReserveResources(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).get.as[org.apache.mesos.v1.mesos.AgentID],
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.scala.collection.Seq[org.apache.mesos.v1.mesos.Resource]]).getOrElse(_root_.scala.collection.Seq.empty)
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = master.Call.javaDescriptor.getNestedTypes.get(5)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = master.Call.scalaDescriptor.nestedMessages(5)
    def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
      var __out: _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => __out = org.apache.mesos.v1.mesos.AgentID
        case 2 => __out = org.apache.mesos.v1.mesos.Resource
      }
      __out
    }
    def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = master.Call.ReserveResources(
      agentId = org.apache.mesos.v1.mesos.AgentID.defaultInstance
    )
    implicit class ReserveResourcesLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.ReserveResources]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, Call.ReserveResources](_l) {
      def agentId: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.AgentID] = field(_.agentId)((c_, f_) => c_.copy(agentId = f_))
      def resources: _root_.com.trueaccord.lenses.Lens[UpperPB, _root_.scala.collection.Seq[org.apache.mesos.v1.mesos.Resource]] = field(_.resources)((c_, f_) => c_.copy(resources = f_))
    }
    final val AGENT_ID_FIELD_NUMBER = 1
    final val RESOURCES_FIELD_NUMBER = 2
  }
  
  /** Unreserve resources dynamically on a specific agent.
    */
  @SerialVersionUID(0L)
  final case class UnreserveResources(
      agentId: org.apache.mesos.v1.mesos.AgentID,
      resources: _root_.scala.collection.Seq[org.apache.mesos.v1.mesos.Resource] = _root_.scala.collection.Seq.empty
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[UnreserveResources] with com.trueaccord.lenses.Updatable[UnreserveResources] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(agentId.serializedSize) + agentId.serializedSize
        resources.foreach(resources => __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(resources.serializedSize) + resources.serializedSize)
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(agentId.serializedSize)
        agentId.writeTo(_output__)
        resources.foreach { __v =>
          _output__.writeTag(2, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        };
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): Call.UnreserveResources = {
        var __agentId = this.agentId
        val __resources = (_root_.scala.collection.immutable.Vector.newBuilder[org.apache.mesos.v1.mesos.Resource] ++= this.resources)
        var __requiredFields0: Long = 0x1L
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __agentId = _root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __agentId)
              __requiredFields0 &= 0xfffffffffffffffeL
            case 18 =>
              __resources += _root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, org.apache.mesos.v1.mesos.Resource.defaultInstance)
            case tag => _input__.skipField(tag)
          }
        }
        if (__requiredFields0 != 0L) { throw new _root_.com.google.protobuf.InvalidProtocolBufferException("Message missing required fields.") } 
        master.Call.UnreserveResources(
            agentId = __agentId,
            resources = __resources.result()
        )
      }
      def withAgentId(__v: org.apache.mesos.v1.mesos.AgentID): UnreserveResources = copy(agentId = __v)
      def clearResources = copy(resources = _root_.scala.collection.Seq.empty)
      def addResources(__vs: org.apache.mesos.v1.mesos.Resource*): UnreserveResources = addAllResources(__vs)
      def addAllResources(__vs: TraversableOnce[org.apache.mesos.v1.mesos.Resource]): UnreserveResources = copy(resources = resources ++ __vs)
      def withResources(__v: _root_.scala.collection.Seq[org.apache.mesos.v1.mesos.Resource]): UnreserveResources = copy(resources = __v)
      def getFieldByNumber(__fieldNumber: Int): scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => agentId
          case 2 => resources
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => agentId.toPMessage
          case 2 => _root_.scalapb.descriptors.PRepeated(resources.map(_.toPMessage)(_root_.scala.collection.breakOut))
        }
      }
      override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = master.Call.UnreserveResources
  }
  
  object UnreserveResources extends com.trueaccord.scalapb.GeneratedMessageCompanion[Call.UnreserveResources] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Call.UnreserveResources] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): Call.UnreserveResources = {
      require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      master.Call.UnreserveResources(
        __fieldsMap(__fields.get(0)).asInstanceOf[org.apache.mesos.v1.mesos.AgentID],
        __fieldsMap.getOrElse(__fields.get(1), Nil).asInstanceOf[_root_.scala.collection.Seq[org.apache.mesos.v1.mesos.Resource]]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[Call.UnreserveResources] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        master.Call.UnreserveResources(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).get.as[org.apache.mesos.v1.mesos.AgentID],
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.scala.collection.Seq[org.apache.mesos.v1.mesos.Resource]]).getOrElse(_root_.scala.collection.Seq.empty)
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = master.Call.javaDescriptor.getNestedTypes.get(6)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = master.Call.scalaDescriptor.nestedMessages(6)
    def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
      var __out: _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => __out = org.apache.mesos.v1.mesos.AgentID
        case 2 => __out = org.apache.mesos.v1.mesos.Resource
      }
      __out
    }
    def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = master.Call.UnreserveResources(
      agentId = org.apache.mesos.v1.mesos.AgentID.defaultInstance
    )
    implicit class UnreserveResourcesLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.UnreserveResources]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, Call.UnreserveResources](_l) {
      def agentId: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.AgentID] = field(_.agentId)((c_, f_) => c_.copy(agentId = f_))
      def resources: _root_.com.trueaccord.lenses.Lens[UpperPB, _root_.scala.collection.Seq[org.apache.mesos.v1.mesos.Resource]] = field(_.resources)((c_, f_) => c_.copy(resources = f_))
    }
    final val AGENT_ID_FIELD_NUMBER = 1
    final val RESOURCES_FIELD_NUMBER = 2
  }
  
  /** Create persistent volumes on reserved resources. The request is forwarded
    * asynchronously to the Mesos agent where the reserved resources are located.
    * That asynchronous message may not be delivered or creating the volumes at
    * the agent might fail. Volume creation can be verified by sending a
    * `GET_VOLUMES` call.
    */
  @SerialVersionUID(0L)
  final case class CreateVolumes(
      agentId: org.apache.mesos.v1.mesos.AgentID,
      volumes: _root_.scala.collection.Seq[org.apache.mesos.v1.mesos.Resource] = _root_.scala.collection.Seq.empty
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[CreateVolumes] with com.trueaccord.lenses.Updatable[CreateVolumes] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(agentId.serializedSize) + agentId.serializedSize
        volumes.foreach(volumes => __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(volumes.serializedSize) + volumes.serializedSize)
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(agentId.serializedSize)
        agentId.writeTo(_output__)
        volumes.foreach { __v =>
          _output__.writeTag(2, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        };
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): Call.CreateVolumes = {
        var __agentId = this.agentId
        val __volumes = (_root_.scala.collection.immutable.Vector.newBuilder[org.apache.mesos.v1.mesos.Resource] ++= this.volumes)
        var __requiredFields0: Long = 0x1L
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __agentId = _root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __agentId)
              __requiredFields0 &= 0xfffffffffffffffeL
            case 18 =>
              __volumes += _root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, org.apache.mesos.v1.mesos.Resource.defaultInstance)
            case tag => _input__.skipField(tag)
          }
        }
        if (__requiredFields0 != 0L) { throw new _root_.com.google.protobuf.InvalidProtocolBufferException("Message missing required fields.") } 
        master.Call.CreateVolumes(
            agentId = __agentId,
            volumes = __volumes.result()
        )
      }
      def withAgentId(__v: org.apache.mesos.v1.mesos.AgentID): CreateVolumes = copy(agentId = __v)
      def clearVolumes = copy(volumes = _root_.scala.collection.Seq.empty)
      def addVolumes(__vs: org.apache.mesos.v1.mesos.Resource*): CreateVolumes = addAllVolumes(__vs)
      def addAllVolumes(__vs: TraversableOnce[org.apache.mesos.v1.mesos.Resource]): CreateVolumes = copy(volumes = volumes ++ __vs)
      def withVolumes(__v: _root_.scala.collection.Seq[org.apache.mesos.v1.mesos.Resource]): CreateVolumes = copy(volumes = __v)
      def getFieldByNumber(__fieldNumber: Int): scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => agentId
          case 2 => volumes
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => agentId.toPMessage
          case 2 => _root_.scalapb.descriptors.PRepeated(volumes.map(_.toPMessage)(_root_.scala.collection.breakOut))
        }
      }
      override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = master.Call.CreateVolumes
  }
  
  object CreateVolumes extends com.trueaccord.scalapb.GeneratedMessageCompanion[Call.CreateVolumes] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Call.CreateVolumes] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): Call.CreateVolumes = {
      require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      master.Call.CreateVolumes(
        __fieldsMap(__fields.get(0)).asInstanceOf[org.apache.mesos.v1.mesos.AgentID],
        __fieldsMap.getOrElse(__fields.get(1), Nil).asInstanceOf[_root_.scala.collection.Seq[org.apache.mesos.v1.mesos.Resource]]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[Call.CreateVolumes] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        master.Call.CreateVolumes(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).get.as[org.apache.mesos.v1.mesos.AgentID],
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.scala.collection.Seq[org.apache.mesos.v1.mesos.Resource]]).getOrElse(_root_.scala.collection.Seq.empty)
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = master.Call.javaDescriptor.getNestedTypes.get(7)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = master.Call.scalaDescriptor.nestedMessages(7)
    def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
      var __out: _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => __out = org.apache.mesos.v1.mesos.AgentID
        case 2 => __out = org.apache.mesos.v1.mesos.Resource
      }
      __out
    }
    def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = master.Call.CreateVolumes(
      agentId = org.apache.mesos.v1.mesos.AgentID.defaultInstance
    )
    implicit class CreateVolumesLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.CreateVolumes]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, Call.CreateVolumes](_l) {
      def agentId: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.AgentID] = field(_.agentId)((c_, f_) => c_.copy(agentId = f_))
      def volumes: _root_.com.trueaccord.lenses.Lens[UpperPB, _root_.scala.collection.Seq[org.apache.mesos.v1.mesos.Resource]] = field(_.volumes)((c_, f_) => c_.copy(volumes = f_))
    }
    final val AGENT_ID_FIELD_NUMBER = 1
    final val VOLUMES_FIELD_NUMBER = 2
  }
  
  /** Destroy persistent volumes. The request is forwarded asynchronously to the
    * Mesos agent where the reserved resources are located. That asynchronous
    * message may not be delivered or destroying the volumes at the agent might
    * fail. Volume deletion can be verified by sending a `GET_VOLUMES` call.
    */
  @SerialVersionUID(0L)
  final case class DestroyVolumes(
      agentId: org.apache.mesos.v1.mesos.AgentID,
      volumes: _root_.scala.collection.Seq[org.apache.mesos.v1.mesos.Resource] = _root_.scala.collection.Seq.empty
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[DestroyVolumes] with com.trueaccord.lenses.Updatable[DestroyVolumes] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(agentId.serializedSize) + agentId.serializedSize
        volumes.foreach(volumes => __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(volumes.serializedSize) + volumes.serializedSize)
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(agentId.serializedSize)
        agentId.writeTo(_output__)
        volumes.foreach { __v =>
          _output__.writeTag(2, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        };
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): Call.DestroyVolumes = {
        var __agentId = this.agentId
        val __volumes = (_root_.scala.collection.immutable.Vector.newBuilder[org.apache.mesos.v1.mesos.Resource] ++= this.volumes)
        var __requiredFields0: Long = 0x1L
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __agentId = _root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __agentId)
              __requiredFields0 &= 0xfffffffffffffffeL
            case 18 =>
              __volumes += _root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, org.apache.mesos.v1.mesos.Resource.defaultInstance)
            case tag => _input__.skipField(tag)
          }
        }
        if (__requiredFields0 != 0L) { throw new _root_.com.google.protobuf.InvalidProtocolBufferException("Message missing required fields.") } 
        master.Call.DestroyVolumes(
            agentId = __agentId,
            volumes = __volumes.result()
        )
      }
      def withAgentId(__v: org.apache.mesos.v1.mesos.AgentID): DestroyVolumes = copy(agentId = __v)
      def clearVolumes = copy(volumes = _root_.scala.collection.Seq.empty)
      def addVolumes(__vs: org.apache.mesos.v1.mesos.Resource*): DestroyVolumes = addAllVolumes(__vs)
      def addAllVolumes(__vs: TraversableOnce[org.apache.mesos.v1.mesos.Resource]): DestroyVolumes = copy(volumes = volumes ++ __vs)
      def withVolumes(__v: _root_.scala.collection.Seq[org.apache.mesos.v1.mesos.Resource]): DestroyVolumes = copy(volumes = __v)
      def getFieldByNumber(__fieldNumber: Int): scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => agentId
          case 2 => volumes
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => agentId.toPMessage
          case 2 => _root_.scalapb.descriptors.PRepeated(volumes.map(_.toPMessage)(_root_.scala.collection.breakOut))
        }
      }
      override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = master.Call.DestroyVolumes
  }
  
  object DestroyVolumes extends com.trueaccord.scalapb.GeneratedMessageCompanion[Call.DestroyVolumes] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Call.DestroyVolumes] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): Call.DestroyVolumes = {
      require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      master.Call.DestroyVolumes(
        __fieldsMap(__fields.get(0)).asInstanceOf[org.apache.mesos.v1.mesos.AgentID],
        __fieldsMap.getOrElse(__fields.get(1), Nil).asInstanceOf[_root_.scala.collection.Seq[org.apache.mesos.v1.mesos.Resource]]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[Call.DestroyVolumes] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        master.Call.DestroyVolumes(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).get.as[org.apache.mesos.v1.mesos.AgentID],
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.scala.collection.Seq[org.apache.mesos.v1.mesos.Resource]]).getOrElse(_root_.scala.collection.Seq.empty)
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = master.Call.javaDescriptor.getNestedTypes.get(8)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = master.Call.scalaDescriptor.nestedMessages(8)
    def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
      var __out: _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => __out = org.apache.mesos.v1.mesos.AgentID
        case 2 => __out = org.apache.mesos.v1.mesos.Resource
      }
      __out
    }
    def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = master.Call.DestroyVolumes(
      agentId = org.apache.mesos.v1.mesos.AgentID.defaultInstance
    )
    implicit class DestroyVolumesLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.DestroyVolumes]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, Call.DestroyVolumes](_l) {
      def agentId: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.AgentID] = field(_.agentId)((c_, f_) => c_.copy(agentId = f_))
      def volumes: _root_.com.trueaccord.lenses.Lens[UpperPB, _root_.scala.collection.Seq[org.apache.mesos.v1.mesos.Resource]] = field(_.volumes)((c_, f_) => c_.copy(volumes = f_))
    }
    final val AGENT_ID_FIELD_NUMBER = 1
    final val VOLUMES_FIELD_NUMBER = 2
  }
  
  /** Updates the cluster's maintenance schedule.
    */
  @SerialVersionUID(0L)
  final case class UpdateMaintenanceSchedule(
      schedule: Schedule
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[UpdateMaintenanceSchedule] with com.trueaccord.lenses.Updatable[UpdateMaintenanceSchedule] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(schedule.serializedSize) + schedule.serializedSize
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(schedule.serializedSize)
        schedule.writeTo(_output__)
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): Call.UpdateMaintenanceSchedule = {
        var __schedule = this.schedule
        var __requiredFields0: Long = 0x1L
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __schedule = _root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __schedule)
              __requiredFields0 &= 0xfffffffffffffffeL
            case tag => _input__.skipField(tag)
          }
        }
        if (__requiredFields0 != 0L) { throw new _root_.com.google.protobuf.InvalidProtocolBufferException("Message missing required fields.") } 
        master.Call.UpdateMaintenanceSchedule(
            schedule = __schedule
        )
      }
      def withSchedule(__v: Schedule): UpdateMaintenanceSchedule = copy(schedule = __v)
      def getFieldByNumber(__fieldNumber: Int): scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => schedule
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => schedule.toPMessage
        }
      }
      override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = master.Call.UpdateMaintenanceSchedule
  }
  
  object UpdateMaintenanceSchedule extends com.trueaccord.scalapb.GeneratedMessageCompanion[Call.UpdateMaintenanceSchedule] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Call.UpdateMaintenanceSchedule] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): Call.UpdateMaintenanceSchedule = {
      require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      master.Call.UpdateMaintenanceSchedule(
        __fieldsMap(__fields.get(0)).asInstanceOf[Schedule]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[Call.UpdateMaintenanceSchedule] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        master.Call.UpdateMaintenanceSchedule(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).get.as[Schedule]
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = master.Call.javaDescriptor.getNestedTypes.get(9)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = master.Call.scalaDescriptor.nestedMessages(9)
    def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
      var __out: _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => __out = maintenance.Schedule
      }
      __out
    }
    def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = master.Call.UpdateMaintenanceSchedule(
      schedule = maintenance.Schedule.defaultInstance
    )
    implicit class UpdateMaintenanceScheduleLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.UpdateMaintenanceSchedule]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, Call.UpdateMaintenanceSchedule](_l) {
      def schedule: _root_.com.trueaccord.lenses.Lens[UpperPB, Schedule] = field(_.schedule)((c_, f_) => c_.copy(schedule = f_))
    }
    final val SCHEDULE_FIELD_NUMBER = 1
  }
  
  /** Starts the maintenance of the cluster, this would bring a set of machines
    * down.
    */
  @SerialVersionUID(0L)
  final case class StartMaintenance(
      machines: _root_.scala.collection.Seq[org.apache.mesos.v1.mesos.MachineID] = _root_.scala.collection.Seq.empty
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[StartMaintenance] with com.trueaccord.lenses.Updatable[StartMaintenance] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        machines.foreach(machines => __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(machines.serializedSize) + machines.serializedSize)
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
        machines.foreach { __v =>
          _output__.writeTag(1, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        };
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): Call.StartMaintenance = {
        val __machines = (_root_.scala.collection.immutable.Vector.newBuilder[org.apache.mesos.v1.mesos.MachineID] ++= this.machines)
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __machines += _root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, org.apache.mesos.v1.mesos.MachineID.defaultInstance)
            case tag => _input__.skipField(tag)
          }
        }
        master.Call.StartMaintenance(
            machines = __machines.result()
        )
      }
      def clearMachines = copy(machines = _root_.scala.collection.Seq.empty)
      def addMachines(__vs: org.apache.mesos.v1.mesos.MachineID*): StartMaintenance = addAllMachines(__vs)
      def addAllMachines(__vs: TraversableOnce[org.apache.mesos.v1.mesos.MachineID]): StartMaintenance = copy(machines = machines ++ __vs)
      def withMachines(__v: _root_.scala.collection.Seq[org.apache.mesos.v1.mesos.MachineID]): StartMaintenance = copy(machines = __v)
      def getFieldByNumber(__fieldNumber: Int): scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => machines
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => _root_.scalapb.descriptors.PRepeated(machines.map(_.toPMessage)(_root_.scala.collection.breakOut))
        }
      }
      override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = master.Call.StartMaintenance
  }
  
  object StartMaintenance extends com.trueaccord.scalapb.GeneratedMessageCompanion[Call.StartMaintenance] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Call.StartMaintenance] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): Call.StartMaintenance = {
      require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      master.Call.StartMaintenance(
        __fieldsMap.getOrElse(__fields.get(0), Nil).asInstanceOf[_root_.scala.collection.Seq[org.apache.mesos.v1.mesos.MachineID]]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[Call.StartMaintenance] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        master.Call.StartMaintenance(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.collection.Seq[org.apache.mesos.v1.mesos.MachineID]]).getOrElse(_root_.scala.collection.Seq.empty)
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = master.Call.javaDescriptor.getNestedTypes.get(10)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = master.Call.scalaDescriptor.nestedMessages(10)
    def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
      var __out: _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => __out = org.apache.mesos.v1.mesos.MachineID
      }
      __out
    }
    def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = master.Call.StartMaintenance(
    )
    implicit class StartMaintenanceLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.StartMaintenance]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, Call.StartMaintenance](_l) {
      def machines: _root_.com.trueaccord.lenses.Lens[UpperPB, _root_.scala.collection.Seq[org.apache.mesos.v1.mesos.MachineID]] = field(_.machines)((c_, f_) => c_.copy(machines = f_))
    }
    final val MACHINES_FIELD_NUMBER = 1
  }
  
  /** Stops the maintenance of the cluster, this would bring a set of machines
    * back up.
    */
  @SerialVersionUID(0L)
  final case class StopMaintenance(
      machines: _root_.scala.collection.Seq[org.apache.mesos.v1.mesos.MachineID] = _root_.scala.collection.Seq.empty
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[StopMaintenance] with com.trueaccord.lenses.Updatable[StopMaintenance] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        machines.foreach(machines => __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(machines.serializedSize) + machines.serializedSize)
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
        machines.foreach { __v =>
          _output__.writeTag(1, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        };
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): Call.StopMaintenance = {
        val __machines = (_root_.scala.collection.immutable.Vector.newBuilder[org.apache.mesos.v1.mesos.MachineID] ++= this.machines)
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __machines += _root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, org.apache.mesos.v1.mesos.MachineID.defaultInstance)
            case tag => _input__.skipField(tag)
          }
        }
        master.Call.StopMaintenance(
            machines = __machines.result()
        )
      }
      def clearMachines = copy(machines = _root_.scala.collection.Seq.empty)
      def addMachines(__vs: org.apache.mesos.v1.mesos.MachineID*): StopMaintenance = addAllMachines(__vs)
      def addAllMachines(__vs: TraversableOnce[org.apache.mesos.v1.mesos.MachineID]): StopMaintenance = copy(machines = machines ++ __vs)
      def withMachines(__v: _root_.scala.collection.Seq[org.apache.mesos.v1.mesos.MachineID]): StopMaintenance = copy(machines = __v)
      def getFieldByNumber(__fieldNumber: Int): scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => machines
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => _root_.scalapb.descriptors.PRepeated(machines.map(_.toPMessage)(_root_.scala.collection.breakOut))
        }
      }
      override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = master.Call.StopMaintenance
  }
  
  object StopMaintenance extends com.trueaccord.scalapb.GeneratedMessageCompanion[Call.StopMaintenance] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Call.StopMaintenance] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): Call.StopMaintenance = {
      require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      master.Call.StopMaintenance(
        __fieldsMap.getOrElse(__fields.get(0), Nil).asInstanceOf[_root_.scala.collection.Seq[org.apache.mesos.v1.mesos.MachineID]]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[Call.StopMaintenance] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        master.Call.StopMaintenance(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.collection.Seq[org.apache.mesos.v1.mesos.MachineID]]).getOrElse(_root_.scala.collection.Seq.empty)
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = master.Call.javaDescriptor.getNestedTypes.get(11)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = master.Call.scalaDescriptor.nestedMessages(11)
    def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
      var __out: _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => __out = org.apache.mesos.v1.mesos.MachineID
      }
      __out
    }
    def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = master.Call.StopMaintenance(
    )
    implicit class StopMaintenanceLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.StopMaintenance]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, Call.StopMaintenance](_l) {
      def machines: _root_.com.trueaccord.lenses.Lens[UpperPB, _root_.scala.collection.Seq[org.apache.mesos.v1.mesos.MachineID]] = field(_.machines)((c_, f_) => c_.copy(machines = f_))
    }
    final val MACHINES_FIELD_NUMBER = 1
  }
  
  /** Sets the quota for resources to be used by a particular role.
    */
  @SerialVersionUID(0L)
  final case class SetQuota(
      quotaRequest: QuotaRequest
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[SetQuota] with com.trueaccord.lenses.Updatable[SetQuota] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(quotaRequest.serializedSize) + quotaRequest.serializedSize
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(quotaRequest.serializedSize)
        quotaRequest.writeTo(_output__)
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): Call.SetQuota = {
        var __quotaRequest = this.quotaRequest
        var __requiredFields0: Long = 0x1L
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __quotaRequest = _root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __quotaRequest)
              __requiredFields0 &= 0xfffffffffffffffeL
            case tag => _input__.skipField(tag)
          }
        }
        if (__requiredFields0 != 0L) { throw new _root_.com.google.protobuf.InvalidProtocolBufferException("Message missing required fields.") } 
        master.Call.SetQuota(
            quotaRequest = __quotaRequest
        )
      }
      def withQuotaRequest(__v: QuotaRequest): SetQuota = copy(quotaRequest = __v)
      def getFieldByNumber(__fieldNumber: Int): scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => quotaRequest
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => quotaRequest.toPMessage
        }
      }
      override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = master.Call.SetQuota
  }
  
  object SetQuota extends com.trueaccord.scalapb.GeneratedMessageCompanion[Call.SetQuota] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Call.SetQuota] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): Call.SetQuota = {
      require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      master.Call.SetQuota(
        __fieldsMap(__fields.get(0)).asInstanceOf[QuotaRequest]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[Call.SetQuota] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        master.Call.SetQuota(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).get.as[QuotaRequest]
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = master.Call.javaDescriptor.getNestedTypes.get(12)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = master.Call.scalaDescriptor.nestedMessages(12)
    def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
      var __out: _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => __out = quota.QuotaRequest
      }
      __out
    }
    def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = master.Call.SetQuota(
      quotaRequest = quota.QuotaRequest.defaultInstance
    )
    implicit class SetQuotaLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.SetQuota]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, Call.SetQuota](_l) {
      def quotaRequest: _root_.com.trueaccord.lenses.Lens[UpperPB, QuotaRequest] = field(_.quotaRequest)((c_, f_) => c_.copy(quotaRequest = f_))
    }
    final val QUOTA_REQUEST_FIELD_NUMBER = 1
  }
  
  @SerialVersionUID(0L)
  final case class RemoveQuota(
      role: String
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[RemoveQuota] with com.trueaccord.lenses.Updatable[RemoveQuota] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, role)
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
        _output__.writeString(1, role)
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): Call.RemoveQuota = {
        var __role = this.role
        var __requiredFields0: Long = 0x1L
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __role = _input__.readString()
              __requiredFields0 &= 0xfffffffffffffffeL
            case tag => _input__.skipField(tag)
          }
        }
        if (__requiredFields0 != 0L) { throw new _root_.com.google.protobuf.InvalidProtocolBufferException("Message missing required fields.") } 
        master.Call.RemoveQuota(
            role = __role
        )
      }
      def withRole(__v: String): RemoveQuota = copy(role = __v)
      def getFieldByNumber(__fieldNumber: Int): scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => role
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => _root_.scalapb.descriptors.PString(role)
        }
      }
      override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = master.Call.RemoveQuota
  }
  
  object RemoveQuota extends com.trueaccord.scalapb.GeneratedMessageCompanion[Call.RemoveQuota] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Call.RemoveQuota] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): Call.RemoveQuota = {
      require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      master.Call.RemoveQuota(
        __fieldsMap(__fields.get(0)).asInstanceOf[String]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[Call.RemoveQuota] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        master.Call.RemoveQuota(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).get.as[String]
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = master.Call.javaDescriptor.getNestedTypes.get(13)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = master.Call.scalaDescriptor.nestedMessages(13)
    def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__fieldNumber)
    def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = master.Call.RemoveQuota(
      role = ""
    )
    implicit class RemoveQuotaLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.RemoveQuota]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, Call.RemoveQuota](_l) {
      def role: _root_.com.trueaccord.lenses.Lens[UpperPB, String] = field(_.role)((c_, f_) => c_.copy(role = f_))
    }
    final val ROLE_FIELD_NUMBER = 1
  }
  
  implicit class CallLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, Call]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, Call](_l) {
    def `type`: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.Type] = field(_.getType)((c_, f_) => c_.copy(`type` = Some(f_)))
    def optionalType: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Call.Type]] = field(_.`type`)((c_, f_) => c_.copy(`type` = f_))
    def getMetrics: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.GetMetrics] = field(_.getGetMetrics)((c_, f_) => c_.copy(getMetrics = Some(f_)))
    def optionalGetMetrics: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Call.GetMetrics]] = field(_.getMetrics)((c_, f_) => c_.copy(getMetrics = f_))
    def setLoggingLevel: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.SetLoggingLevel] = field(_.getSetLoggingLevel)((c_, f_) => c_.copy(setLoggingLevel = Some(f_)))
    def optionalSetLoggingLevel: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Call.SetLoggingLevel]] = field(_.setLoggingLevel)((c_, f_) => c_.copy(setLoggingLevel = f_))
    def listFiles: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.ListFiles] = field(_.getListFiles)((c_, f_) => c_.copy(listFiles = Some(f_)))
    def optionalListFiles: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Call.ListFiles]] = field(_.listFiles)((c_, f_) => c_.copy(listFiles = f_))
    def readFile: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.ReadFile] = field(_.getReadFile)((c_, f_) => c_.copy(readFile = Some(f_)))
    def optionalReadFile: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Call.ReadFile]] = field(_.readFile)((c_, f_) => c_.copy(readFile = f_))
    def updateWeights: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.UpdateWeights] = field(_.getUpdateWeights)((c_, f_) => c_.copy(updateWeights = Some(f_)))
    def optionalUpdateWeights: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Call.UpdateWeights]] = field(_.updateWeights)((c_, f_) => c_.copy(updateWeights = f_))
    def reserveResources: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.ReserveResources] = field(_.getReserveResources)((c_, f_) => c_.copy(reserveResources = Some(f_)))
    def optionalReserveResources: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Call.ReserveResources]] = field(_.reserveResources)((c_, f_) => c_.copy(reserveResources = f_))
    def unreserveResources: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.UnreserveResources] = field(_.getUnreserveResources)((c_, f_) => c_.copy(unreserveResources = Some(f_)))
    def optionalUnreserveResources: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Call.UnreserveResources]] = field(_.unreserveResources)((c_, f_) => c_.copy(unreserveResources = f_))
    def createVolumes: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.CreateVolumes] = field(_.getCreateVolumes)((c_, f_) => c_.copy(createVolumes = Some(f_)))
    def optionalCreateVolumes: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Call.CreateVolumes]] = field(_.createVolumes)((c_, f_) => c_.copy(createVolumes = f_))
    def destroyVolumes: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.DestroyVolumes] = field(_.getDestroyVolumes)((c_, f_) => c_.copy(destroyVolumes = Some(f_)))
    def optionalDestroyVolumes: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Call.DestroyVolumes]] = field(_.destroyVolumes)((c_, f_) => c_.copy(destroyVolumes = f_))
    def updateMaintenanceSchedule: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.UpdateMaintenanceSchedule] = field(_.getUpdateMaintenanceSchedule)((c_, f_) => c_.copy(updateMaintenanceSchedule = Some(f_)))
    def optionalUpdateMaintenanceSchedule: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Call.UpdateMaintenanceSchedule]] = field(_.updateMaintenanceSchedule)((c_, f_) => c_.copy(updateMaintenanceSchedule = f_))
    def startMaintenance: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.StartMaintenance] = field(_.getStartMaintenance)((c_, f_) => c_.copy(startMaintenance = Some(f_)))
    def optionalStartMaintenance: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Call.StartMaintenance]] = field(_.startMaintenance)((c_, f_) => c_.copy(startMaintenance = f_))
    def stopMaintenance: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.StopMaintenance] = field(_.getStopMaintenance)((c_, f_) => c_.copy(stopMaintenance = Some(f_)))
    def optionalStopMaintenance: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Call.StopMaintenance]] = field(_.stopMaintenance)((c_, f_) => c_.copy(stopMaintenance = f_))
    def setQuota: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.SetQuota] = field(_.getSetQuota)((c_, f_) => c_.copy(setQuota = Some(f_)))
    def optionalSetQuota: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Call.SetQuota]] = field(_.setQuota)((c_, f_) => c_.copy(setQuota = f_))
    def removeQuota: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.RemoveQuota] = field(_.getRemoveQuota)((c_, f_) => c_.copy(removeQuota = Some(f_)))
    def optionalRemoveQuota: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Call.RemoveQuota]] = field(_.removeQuota)((c_, f_) => c_.copy(removeQuota = f_))
  }
  final val TYPE_FIELD_NUMBER = 1
  final val GET_METRICS_FIELD_NUMBER = 2
  final val SET_LOGGING_LEVEL_FIELD_NUMBER = 3
  final val LIST_FILES_FIELD_NUMBER = 4
  final val READ_FILE_FIELD_NUMBER = 5
  final val UPDATE_WEIGHTS_FIELD_NUMBER = 6
  final val RESERVE_RESOURCES_FIELD_NUMBER = 7
  final val UNRESERVE_RESOURCES_FIELD_NUMBER = 8
  final val CREATE_VOLUMES_FIELD_NUMBER = 9
  final val DESTROY_VOLUMES_FIELD_NUMBER = 10
  final val UPDATE_MAINTENANCE_SCHEDULE_FIELD_NUMBER = 11
  final val START_MAINTENANCE_FIELD_NUMBER = 12
  final val STOP_MAINTENANCE_FIELD_NUMBER = 13
  final val SET_QUOTA_FIELD_NUMBER = 14
  final val REMOVE_QUOTA_FIELD_NUMBER = 15
}
