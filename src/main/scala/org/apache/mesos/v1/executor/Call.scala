// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO2

package org.apache.mesos.v1.executor

import org.apache.mesos.v1.executor

/** *
  * Executor call API.
  *
  * Like Event, a Call is described using the standard protocol buffer
  * "union" trick (see above).
  *
  * @param executorId
  *   Identifies the executor which generated this call.
  * @param type
  *   Type of the call, indicates which optional field below should be
  *   present if that type has a nested message definition.
  *   In case type is SUBSCRIBED, no message needs to be set.
  *   See comments on `Event::Type` above on the reasoning behind this
  *   field being optional.
  */
@SerialVersionUID(0L)
final case class Call(
                       executorId: org.apache.mesos.v1.mesos.ExecutorID,
                       frameworkId: org.apache.mesos.v1.mesos.FrameworkID,
                       `type`: scala.Option[Call.Type] = None,
                       subscribe: scala.Option[Call.Subscribe] = None,
                       update: scala.Option[Call.Update] = None,
                       message: scala.Option[Call.Message] = None
    ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Call] with com.trueaccord.lenses.Updatable[Call] {
    @transient
    private[this] var __serializedSizeCachedValue: Int = 0
    private[this] def __computeSerializedValue(): Int = {
      var __size = 0
      __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(executorId.serializedSize) + executorId.serializedSize
      __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(frameworkId.serializedSize) + frameworkId.serializedSize
      if (`type`.isDefined) { __size += _root_.com.google.protobuf.CodedOutputStream.computeEnumSize(3, `type`.get.value) }
      if (subscribe.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(subscribe.get.serializedSize) + subscribe.get.serializedSize }
      if (update.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(update.get.serializedSize) + update.get.serializedSize }
      if (message.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(message.get.serializedSize) + message.get.serializedSize }
      __size
    }
    final override def serializedSize: Int = {
      var read = __serializedSizeCachedValue
      if (read == 0) {
        read = __computeSerializedValue()
        __serializedSizeCachedValue = read
      }
      read
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
      _output__.writeTag(1, 2)
      _output__.writeUInt32NoTag(executorId.serializedSize)
      executorId.writeTo(_output__)
      _output__.writeTag(2, 2)
      _output__.writeUInt32NoTag(frameworkId.serializedSize)
      frameworkId.writeTo(_output__)
      `type`.foreach { __v =>
        _output__.writeEnum(3, __v.value)
      };
      subscribe.foreach { __v =>
        _output__.writeTag(4, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
      update.foreach { __v =>
        _output__.writeTag(5, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
      message.foreach { __v =>
        _output__.writeTag(6, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
    }
    def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): Call = {
      var __executorId = this.executorId
      var __frameworkId = this.frameworkId
      var __type = this.`type`
      var __subscribe = this.subscribe
      var __update = this.update
      var __message = this.message
      var __requiredFields0: Long = 0x3L
      var _done__ = false
      while (!_done__) {
        val _tag__ = _input__.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case 10 =>
            __executorId = _root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __executorId)
            __requiredFields0 &= 0xfffffffffffffffeL
          case 18 =>
            __frameworkId = _root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __frameworkId)
            __requiredFields0 &= 0xfffffffffffffffdL
          case 24 =>
            __type = Some(executor.Call.Type.fromValue(_input__.readEnum()))
          case 34 =>
            __subscribe = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __subscribe.getOrElse(executor.Call.Subscribe.defaultInstance)))
          case 42 =>
            __update = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __update.getOrElse(executor.Call.Update.defaultInstance)))
          case 50 =>
            __message = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __message.getOrElse(executor.Call.Message.defaultInstance)))
          case tag => _input__.skipField(tag)
        }
      }
      if (__requiredFields0 != 0L) { throw new _root_.com.google.protobuf.InvalidProtocolBufferException("Message missing required fields.") } 
      executor.Call(
          executorId = __executorId,
          frameworkId = __frameworkId,
          `type` = __type,
          subscribe = __subscribe,
          update = __update,
          message = __message
      )
    }
    def withExecutorId(__v: org.apache.mesos.v1.mesos.ExecutorID): Call = copy(executorId = __v)
    def withFrameworkId(__v: org.apache.mesos.v1.mesos.FrameworkID): Call = copy(frameworkId = __v)
    def getType: Call.Type = `type`.getOrElse(executor.Call.Type.UNKNOWN)
    def clearType: Call = copy(`type` = None)
    def withType(__v: Call.Type): Call = copy(`type` = Some(__v))
    def getSubscribe: Call.Subscribe = subscribe.getOrElse(executor.Call.Subscribe.defaultInstance)
    def clearSubscribe: Call = copy(subscribe = None)
    def withSubscribe(__v: Call.Subscribe): Call = copy(subscribe = Some(__v))
    def getUpdate: Call.Update = update.getOrElse(executor.Call.Update.defaultInstance)
    def clearUpdate: Call = copy(update = None)
    def withUpdate(__v: Call.Update): Call = copy(update = Some(__v))
    def getMessage: Call.Message = message.getOrElse(executor.Call.Message.defaultInstance)
    def clearMessage: Call = copy(message = None)
    def withMessage(__v: Call.Message): Call = copy(message = Some(__v))
    def getFieldByNumber(__fieldNumber: Int): scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => executorId
        case 2 => frameworkId
        case 3 => `type`.map(_.javaValueDescriptor).orNull
        case 4 => subscribe.orNull
        case 5 => update.orNull
        case 6 => message.orNull
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => executorId.toPMessage
        case 2 => frameworkId.toPMessage
        case 3 => `type`.map(__e => _root_.scalapb.descriptors.PEnum(__e.scalaValueDescriptor)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 4 => subscribe.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 5 => update.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 6 => message.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
      }
    }
    override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
    def companion = executor.Call
}

object Call extends com.trueaccord.scalapb.GeneratedMessageCompanion[Call] {
  implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Call] = this
  def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): Call = {
    require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
    val __fields = javaDescriptor.getFields
    executor.Call(
      __fieldsMap(__fields.get(0)).asInstanceOf[org.apache.mesos.v1.mesos.ExecutorID],
      __fieldsMap(__fields.get(1)).asInstanceOf[org.apache.mesos.v1.mesos.FrameworkID],
      __fieldsMap.get(__fields.get(2)).asInstanceOf[scala.Option[_root_.com.google.protobuf.Descriptors.EnumValueDescriptor]].map(__e => executor.Call.Type.fromValue(__e.getNumber)),
      __fieldsMap.get(__fields.get(3)).asInstanceOf[scala.Option[Call.Subscribe]],
      __fieldsMap.get(__fields.get(4)).asInstanceOf[scala.Option[Call.Update]],
      __fieldsMap.get(__fields.get(5)).asInstanceOf[scala.Option[Call.Message]]
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[Call] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
      executor.Call(
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).get.as[org.apache.mesos.v1.mesos.ExecutorID],
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).get.as[org.apache.mesos.v1.mesos.FrameworkID],
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).flatMap(_.as[scala.Option[_root_.scalapb.descriptors.EnumValueDescriptor]]).map(__e => executor.Call.Type.fromValue(__e.number)),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(4).get).flatMap(_.as[scala.Option[Call.Subscribe]]),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(5).get).flatMap(_.as[scala.Option[Call.Update]]),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(6).get).flatMap(_.as[scala.Option[Call.Message]])
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = ExecutorProto.javaDescriptor.getMessageTypes.get(1)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = ExecutorProto.scalaDescriptor.messages(1)
  def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
    (__fieldNumber: @_root_.scala.unchecked) match {
      case 1 => __out = org.apache.mesos.v1.mesos.ExecutorID
      case 2 => __out = org.apache.mesos.v1.mesos.FrameworkID
      case 4 => __out = executor.Call.Subscribe
      case 5 => __out = executor.Call.Update
      case 6 => __out = executor.Call.Message
    }
    __out
  }
  def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = {
    (__fieldNumber: @_root_.scala.unchecked) match {
      case 3 => executor.Call.Type
    }
  }
  lazy val defaultInstance = executor.Call(
    executorId = org.apache.mesos.v1.mesos.ExecutorID.defaultInstance,
    frameworkId = org.apache.mesos.v1.mesos.FrameworkID.defaultInstance
  )
  sealed trait Type extends _root_.com.trueaccord.scalapb.GeneratedEnum {
    type EnumType = Type
    def isUnknown: Boolean = false
    def isSubscribe: Boolean = false
    def isUpdate: Boolean = false
    def isMessage: Boolean = false
    def companion: _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[Type] = executor.Call.Type
  }
  
  object Type extends _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[Type] {
    implicit def enumCompanion: _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[Type] = this
    @SerialVersionUID(0L)
    case object UNKNOWN extends Type {
      val value = 0
      val index = 0
      val name = "UNKNOWN"
      override def isUnknown: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object SUBSCRIBE extends Type {
      val value = 1
      val index = 1
      val name = "SUBSCRIBE"
      override def isSubscribe: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object UPDATE extends Type {
      val value = 2
      val index = 2
      val name = "UPDATE"
      override def isUpdate: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object MESSAGE extends Type {
      val value = 3
      val index = 3
      val name = "MESSAGE"
      override def isMessage: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case class Unrecognized(value: Int) extends Type with _root_.com.trueaccord.scalapb.UnrecognizedEnum
    
    lazy val values = scala.collection.Seq(UNKNOWN, SUBSCRIBE, UPDATE, MESSAGE)
    def fromValue(value: Int): Type = value match {
      case 0 => UNKNOWN
      case 1 => SUBSCRIBE
      case 2 => UPDATE
      case 3 => MESSAGE
      case __other => Unrecognized(__other)
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.EnumDescriptor = executor.Call.javaDescriptor.getEnumTypes.get(0)
    def scalaDescriptor: _root_.scalapb.descriptors.EnumDescriptor = executor.Call.scalaDescriptor.enums(0)
  }
  /** Request to subscribe with the agent. If subscribing after a disconnection,
    * it must include a list of all the tasks and updates which haven't been
    * acknowledged by the scheduler.
    */
  @SerialVersionUID(0L)
  final case class Subscribe(
      unacknowledgedTasks: _root_.scala.collection.Seq[org.apache.mesos.v1.mesos.TaskInfo] = _root_.scala.collection.Seq.empty,
      unacknowledgedUpdates: _root_.scala.collection.Seq[Call.Update] = _root_.scala.collection.Seq.empty
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Subscribe] with com.trueaccord.lenses.Updatable[Subscribe] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        unacknowledgedTasks.foreach(unacknowledgedTasks => __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(unacknowledgedTasks.serializedSize) + unacknowledgedTasks.serializedSize)
        unacknowledgedUpdates.foreach(unacknowledgedUpdates => __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(unacknowledgedUpdates.serializedSize) + unacknowledgedUpdates.serializedSize)
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
        unacknowledgedTasks.foreach { __v =>
          _output__.writeTag(1, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        };
        unacknowledgedUpdates.foreach { __v =>
          _output__.writeTag(2, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        };
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): Call.Subscribe = {
        val __unacknowledgedTasks = (_root_.scala.collection.immutable.Vector.newBuilder[org.apache.mesos.v1.mesos.TaskInfo] ++= this.unacknowledgedTasks)
        val __unacknowledgedUpdates = (_root_.scala.collection.immutable.Vector.newBuilder[Call.Update] ++= this.unacknowledgedUpdates)
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __unacknowledgedTasks += _root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, org.apache.mesos.v1.mesos.TaskInfo.defaultInstance)
            case 18 =>
              __unacknowledgedUpdates += _root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, executor.Call.Update.defaultInstance)
            case tag => _input__.skipField(tag)
          }
        }
        executor.Call.Subscribe(
            unacknowledgedTasks = __unacknowledgedTasks.result(),
            unacknowledgedUpdates = __unacknowledgedUpdates.result()
        )
      }
      def clearUnacknowledgedTasks = copy(unacknowledgedTasks = _root_.scala.collection.Seq.empty)
      def addUnacknowledgedTasks(__vs: org.apache.mesos.v1.mesos.TaskInfo*): Subscribe = addAllUnacknowledgedTasks(__vs)
      def addAllUnacknowledgedTasks(__vs: TraversableOnce[org.apache.mesos.v1.mesos.TaskInfo]): Subscribe = copy(unacknowledgedTasks = unacknowledgedTasks ++ __vs)
      def withUnacknowledgedTasks(__v: _root_.scala.collection.Seq[org.apache.mesos.v1.mesos.TaskInfo]): Subscribe = copy(unacknowledgedTasks = __v)
      def clearUnacknowledgedUpdates = copy(unacknowledgedUpdates = _root_.scala.collection.Seq.empty)
      def addUnacknowledgedUpdates(__vs: Call.Update*): Subscribe = addAllUnacknowledgedUpdates(__vs)
      def addAllUnacknowledgedUpdates(__vs: TraversableOnce[Call.Update]): Subscribe = copy(unacknowledgedUpdates = unacknowledgedUpdates ++ __vs)
      def withUnacknowledgedUpdates(__v: _root_.scala.collection.Seq[Call.Update]): Subscribe = copy(unacknowledgedUpdates = __v)
      def getFieldByNumber(__fieldNumber: Int): scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => unacknowledgedTasks
          case 2 => unacknowledgedUpdates
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => _root_.scalapb.descriptors.PRepeated(unacknowledgedTasks.map(_.toPMessage)(_root_.scala.collection.breakOut))
          case 2 => _root_.scalapb.descriptors.PRepeated(unacknowledgedUpdates.map(_.toPMessage)(_root_.scala.collection.breakOut))
        }
      }
      override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = executor.Call.Subscribe
  }
  
  object Subscribe extends com.trueaccord.scalapb.GeneratedMessageCompanion[Call.Subscribe] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Call.Subscribe] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): Call.Subscribe = {
      require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      executor.Call.Subscribe(
        __fieldsMap.getOrElse(__fields.get(0), Nil).asInstanceOf[_root_.scala.collection.Seq[org.apache.mesos.v1.mesos.TaskInfo]],
        __fieldsMap.getOrElse(__fields.get(1), Nil).asInstanceOf[_root_.scala.collection.Seq[Call.Update]]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[Call.Subscribe] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        executor.Call.Subscribe(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.collection.Seq[org.apache.mesos.v1.mesos.TaskInfo]]).getOrElse(_root_.scala.collection.Seq.empty),
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.scala.collection.Seq[Call.Update]]).getOrElse(_root_.scala.collection.Seq.empty)
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = executor.Call.javaDescriptor.getNestedTypes.get(0)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = executor.Call.scalaDescriptor.nestedMessages(0)
    def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
      var __out: _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => __out = org.apache.mesos.v1.mesos.TaskInfo
        case 2 => __out = executor.Call.Update
      }
      __out
    }
    def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = executor.Call.Subscribe(
    )
    implicit class SubscribeLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.Subscribe]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, Call.Subscribe](_l) {
      def unacknowledgedTasks: _root_.com.trueaccord.lenses.Lens[UpperPB, _root_.scala.collection.Seq[org.apache.mesos.v1.mesos.TaskInfo]] = field(_.unacknowledgedTasks)((c_, f_) => c_.copy(unacknowledgedTasks = f_))
      def unacknowledgedUpdates: _root_.com.trueaccord.lenses.Lens[UpperPB, _root_.scala.collection.Seq[Call.Update]] = field(_.unacknowledgedUpdates)((c_, f_) => c_.copy(unacknowledgedUpdates = f_))
    }
    final val UNACKNOWLEDGED_TASKS_FIELD_NUMBER = 1
    final val UNACKNOWLEDGED_UPDATES_FIELD_NUMBER = 2
  }
  
  /** Notifies the scheduler that a task has transitioned from one
    * state to another. Status updates should be used by executors
    * to reliably communicate the status of the tasks that they
    * manage. It is crucial that a terminal update (see TaskState
    * in v1/mesos.proto) is sent to the scheduler as soon as the task
    * terminates, in order for Mesos to release the resources allocated
    * to the task. It is the responsibility of the scheduler to
    * explicitly acknowledge the receipt of a status update. See
    * 'Acknowledged' in the 'Events' section above for the semantics.
    */
  @SerialVersionUID(0L)
  final case class Update(
      status: org.apache.mesos.v1.mesos.TaskStatus
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Update] with com.trueaccord.lenses.Updatable[Update] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(status.serializedSize) + status.serializedSize
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(status.serializedSize)
        status.writeTo(_output__)
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): Call.Update = {
        var __status = this.status
        var __requiredFields0: Long = 0x1L
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __status = _root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __status)
              __requiredFields0 &= 0xfffffffffffffffeL
            case tag => _input__.skipField(tag)
          }
        }
        if (__requiredFields0 != 0L) { throw new _root_.com.google.protobuf.InvalidProtocolBufferException("Message missing required fields.") } 
        executor.Call.Update(
            status = __status
        )
      }
      def withStatus(__v: org.apache.mesos.v1.mesos.TaskStatus): Update = copy(status = __v)
      def getFieldByNumber(__fieldNumber: Int): scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => status
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => status.toPMessage
        }
      }
      override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = executor.Call.Update
  }
  
  object Update extends com.trueaccord.scalapb.GeneratedMessageCompanion[Call.Update] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Call.Update] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): Call.Update = {
      require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      executor.Call.Update(
        __fieldsMap(__fields.get(0)).asInstanceOf[org.apache.mesos.v1.mesos.TaskStatus]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[Call.Update] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        executor.Call.Update(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).get.as[org.apache.mesos.v1.mesos.TaskStatus]
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = executor.Call.javaDescriptor.getNestedTypes.get(1)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = executor.Call.scalaDescriptor.nestedMessages(1)
    def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
      var __out: _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => __out = org.apache.mesos.v1.mesos.TaskStatus
      }
      __out
    }
    def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = executor.Call.Update(
      status = org.apache.mesos.v1.mesos.TaskStatus.defaultInstance
    )
    implicit class UpdateLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.Update]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, Call.Update](_l) {
      def status: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.TaskStatus] = field(_.status)((c_, f_) => c_.copy(status = f_))
    }
    final val STATUS_FIELD_NUMBER = 1
  }
  
  /** Sends arbitrary binary data to the scheduler. Note that Mesos
    * neither interprets this data nor makes any guarantees about the
    * delivery of this message to the scheduler.
    * See 'Message' in the 'Events' section.
    */
  @SerialVersionUID(0L)
  final case class Message(
      data: _root_.com.google.protobuf.ByteString
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Message] with com.trueaccord.lenses.Updatable[Message] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        __size += _root_.com.google.protobuf.CodedOutputStream.computeBytesSize(2, data)
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
        _output__.writeBytes(2, data)
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): Call.Message = {
        var __data = this.data
        var __requiredFields0: Long = 0x1L
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 18 =>
              __data = _input__.readBytes()
              __requiredFields0 &= 0xfffffffffffffffeL
            case tag => _input__.skipField(tag)
          }
        }
        if (__requiredFields0 != 0L) { throw new _root_.com.google.protobuf.InvalidProtocolBufferException("Message missing required fields.") } 
        executor.Call.Message(
            data = __data
        )
      }
      def withData(__v: _root_.com.google.protobuf.ByteString): Message = copy(data = __v)
      def getFieldByNumber(__fieldNumber: Int): scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 2 => data
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 2 => _root_.scalapb.descriptors.PByteString(data)
        }
      }
      override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = executor.Call.Message
  }
  
  object Message extends com.trueaccord.scalapb.GeneratedMessageCompanion[Call.Message] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Call.Message] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): Call.Message = {
      require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      executor.Call.Message(
        __fieldsMap(__fields.get(0)).asInstanceOf[_root_.com.google.protobuf.ByteString]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[Call.Message] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        executor.Call.Message(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).get.as[_root_.com.google.protobuf.ByteString]
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = executor.Call.javaDescriptor.getNestedTypes.get(2)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = executor.Call.scalaDescriptor.nestedMessages(2)
    def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__fieldNumber)
    def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = executor.Call.Message(
      data = _root_.com.google.protobuf.ByteString.EMPTY
    )
    implicit class MessageLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.Message]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, Call.Message](_l) {
      def data: _root_.com.trueaccord.lenses.Lens[UpperPB, _root_.com.google.protobuf.ByteString] = field(_.data)((c_, f_) => c_.copy(data = f_))
    }
    final val DATA_FIELD_NUMBER = 2
  }
  
  implicit class CallLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, Call]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, Call](_l) {
    def executorId: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.ExecutorID] = field(_.executorId)((c_, f_) => c_.copy(executorId = f_))
    def frameworkId: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.FrameworkID] = field(_.frameworkId)((c_, f_) => c_.copy(frameworkId = f_))
    def `type`: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.Type] = field(_.getType)((c_, f_) => c_.copy(`type` = Some(f_)))
    def optionalType: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Call.Type]] = field(_.`type`)((c_, f_) => c_.copy(`type` = f_))
    def subscribe: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.Subscribe] = field(_.getSubscribe)((c_, f_) => c_.copy(subscribe = Some(f_)))
    def optionalSubscribe: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Call.Subscribe]] = field(_.subscribe)((c_, f_) => c_.copy(subscribe = f_))
    def update: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.Update] = field(_.getUpdate)((c_, f_) => c_.copy(update = Some(f_)))
    def optionalUpdate: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Call.Update]] = field(_.update)((c_, f_) => c_.copy(update = f_))
    def message: _root_.com.trueaccord.lenses.Lens[UpperPB, Call.Message] = field(_.getMessage)((c_, f_) => c_.copy(message = Some(f_)))
    def optionalMessage: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Call.Message]] = field(_.message)((c_, f_) => c_.copy(message = f_))
  }
  final val EXECUTOR_ID_FIELD_NUMBER = 1
  final val FRAMEWORK_ID_FIELD_NUMBER = 2
  final val TYPE_FIELD_NUMBER = 3
  final val SUBSCRIBE_FIELD_NUMBER = 4
  final val UPDATE_FIELD_NUMBER = 5
  final val MESSAGE_FIELD_NUMBER = 6
}
