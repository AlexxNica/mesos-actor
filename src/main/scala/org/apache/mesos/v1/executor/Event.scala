// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO2

package org.apache.mesos.v1.executor

import org.apache.mesos.v1.executor

/** *
  * Executor event API.
  *
  * An event is described using the standard protocol buffer "union"
  * trick, see https://developers.google.com/protocol-buffers/docs/techniques#union.
  *
  * @param type
  *   Type of the event, indicates which optional field below should be
  *   present if that type has a nested message definition.
  *   Enum fields should be optional, see: MESOS-4997.
  */
@SerialVersionUID(0L)
final case class Event(
                        `type`: scala.Option[Event.Type] = None,
                        subscribed: scala.Option[Event.Subscribed] = None,
                        acknowledged: scala.Option[Event.Acknowledged] = None,
                        launch: scala.Option[Event.Launch] = None,
                        launchGroup: scala.Option[Event.LaunchGroup] = None,
                        kill: scala.Option[Event.Kill] = None,
                        message: scala.Option[Event.Message] = None,
                        error: scala.Option[Event.Error] = None
    ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Event] with com.trueaccord.lenses.Updatable[Event] {
    @transient
    private[this] var __serializedSizeCachedValue: Int = 0
    private[this] def __computeSerializedValue(): Int = {
      var __size = 0
      if (`type`.isDefined) { __size += _root_.com.google.protobuf.CodedOutputStream.computeEnumSize(1, `type`.get.value) }
      if (subscribed.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(subscribed.get.serializedSize) + subscribed.get.serializedSize }
      if (acknowledged.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(acknowledged.get.serializedSize) + acknowledged.get.serializedSize }
      if (launch.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(launch.get.serializedSize) + launch.get.serializedSize }
      if (launchGroup.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(launchGroup.get.serializedSize) + launchGroup.get.serializedSize }
      if (kill.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(kill.get.serializedSize) + kill.get.serializedSize }
      if (message.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(message.get.serializedSize) + message.get.serializedSize }
      if (error.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(error.get.serializedSize) + error.get.serializedSize }
      __size
    }
    final override def serializedSize: Int = {
      var read = __serializedSizeCachedValue
      if (read == 0) {
        read = __computeSerializedValue()
        __serializedSizeCachedValue = read
      }
      read
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
      `type`.foreach { __v =>
        _output__.writeEnum(1, __v.value)
      };
      subscribed.foreach { __v =>
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
      acknowledged.foreach { __v =>
        _output__.writeTag(3, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
      launch.foreach { __v =>
        _output__.writeTag(4, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
      kill.foreach { __v =>
        _output__.writeTag(5, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
      message.foreach { __v =>
        _output__.writeTag(6, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
      error.foreach { __v =>
        _output__.writeTag(7, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
      launchGroup.foreach { __v =>
        _output__.writeTag(8, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
    }
    def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): Event = {
      var __type = this.`type`
      var __subscribed = this.subscribed
      var __acknowledged = this.acknowledged
      var __launch = this.launch
      var __launchGroup = this.launchGroup
      var __kill = this.kill
      var __message = this.message
      var __error = this.error
      var _done__ = false
      while (!_done__) {
        val _tag__ = _input__.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case 8 =>
            __type = Some(executor.Event.Type.fromValue(_input__.readEnum()))
          case 18 =>
            __subscribed = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __subscribed.getOrElse(executor.Event.Subscribed.defaultInstance)))
          case 26 =>
            __acknowledged = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __acknowledged.getOrElse(executor.Event.Acknowledged.defaultInstance)))
          case 34 =>
            __launch = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __launch.getOrElse(executor.Event.Launch.defaultInstance)))
          case 66 =>
            __launchGroup = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __launchGroup.getOrElse(executor.Event.LaunchGroup.defaultInstance)))
          case 42 =>
            __kill = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __kill.getOrElse(executor.Event.Kill.defaultInstance)))
          case 50 =>
            __message = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __message.getOrElse(executor.Event.Message.defaultInstance)))
          case 58 =>
            __error = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __error.getOrElse(executor.Event.Error.defaultInstance)))
          case tag => _input__.skipField(tag)
        }
      }
      executor.Event(
          `type` = __type,
          subscribed = __subscribed,
          acknowledged = __acknowledged,
          launch = __launch,
          launchGroup = __launchGroup,
          kill = __kill,
          message = __message,
          error = __error
      )
    }
    def getType: Event.Type = `type`.getOrElse(executor.Event.Type.UNKNOWN)
    def clearType: Event = copy(`type` = None)
    def withType(__v: Event.Type): Event = copy(`type` = Some(__v))
    def getSubscribed: Event.Subscribed = subscribed.getOrElse(executor.Event.Subscribed.defaultInstance)
    def clearSubscribed: Event = copy(subscribed = None)
    def withSubscribed(__v: Event.Subscribed): Event = copy(subscribed = Some(__v))
    def getAcknowledged: Event.Acknowledged = acknowledged.getOrElse(executor.Event.Acknowledged.defaultInstance)
    def clearAcknowledged: Event = copy(acknowledged = None)
    def withAcknowledged(__v: Event.Acknowledged): Event = copy(acknowledged = Some(__v))
    def getLaunch: Event.Launch = launch.getOrElse(executor.Event.Launch.defaultInstance)
    def clearLaunch: Event = copy(launch = None)
    def withLaunch(__v: Event.Launch): Event = copy(launch = Some(__v))
    def getLaunchGroup: Event.LaunchGroup = launchGroup.getOrElse(executor.Event.LaunchGroup.defaultInstance)
    def clearLaunchGroup: Event = copy(launchGroup = None)
    def withLaunchGroup(__v: Event.LaunchGroup): Event = copy(launchGroup = Some(__v))
    def getKill: Event.Kill = kill.getOrElse(executor.Event.Kill.defaultInstance)
    def clearKill: Event = copy(kill = None)
    def withKill(__v: Event.Kill): Event = copy(kill = Some(__v))
    def getMessage: Event.Message = message.getOrElse(executor.Event.Message.defaultInstance)
    def clearMessage: Event = copy(message = None)
    def withMessage(__v: Event.Message): Event = copy(message = Some(__v))
    def getError: Event.Error = error.getOrElse(executor.Event.Error.defaultInstance)
    def clearError: Event = copy(error = None)
    def withError(__v: Event.Error): Event = copy(error = Some(__v))
    def getFieldByNumber(__fieldNumber: Int): scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => `type`.map(_.javaValueDescriptor).orNull
        case 2 => subscribed.orNull
        case 3 => acknowledged.orNull
        case 4 => launch.orNull
        case 8 => launchGroup.orNull
        case 5 => kill.orNull
        case 6 => message.orNull
        case 7 => error.orNull
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => `type`.map(__e => _root_.scalapb.descriptors.PEnum(__e.scalaValueDescriptor)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 2 => subscribed.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 3 => acknowledged.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 4 => launch.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 8 => launchGroup.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 5 => kill.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 6 => message.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 7 => error.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
      }
    }
    override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
    def companion = executor.Event
}

object Event extends com.trueaccord.scalapb.GeneratedMessageCompanion[Event] {
  implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Event] = this
  def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): Event = {
    require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
    val __fields = javaDescriptor.getFields
    executor.Event(
      __fieldsMap.get(__fields.get(0)).asInstanceOf[scala.Option[_root_.com.google.protobuf.Descriptors.EnumValueDescriptor]].map(__e => executor.Event.Type.fromValue(__e.getNumber)),
      __fieldsMap.get(__fields.get(1)).asInstanceOf[scala.Option[Event.Subscribed]],
      __fieldsMap.get(__fields.get(2)).asInstanceOf[scala.Option[Event.Acknowledged]],
      __fieldsMap.get(__fields.get(3)).asInstanceOf[scala.Option[Event.Launch]],
      __fieldsMap.get(__fields.get(4)).asInstanceOf[scala.Option[Event.LaunchGroup]],
      __fieldsMap.get(__fields.get(5)).asInstanceOf[scala.Option[Event.Kill]],
      __fieldsMap.get(__fields.get(6)).asInstanceOf[scala.Option[Event.Message]],
      __fieldsMap.get(__fields.get(7)).asInstanceOf[scala.Option[Event.Error]]
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[Event] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
      executor.Event(
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).flatMap(_.as[scala.Option[_root_.scalapb.descriptors.EnumValueDescriptor]]).map(__e => executor.Event.Type.fromValue(__e.number)),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[scala.Option[Event.Subscribed]]),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).flatMap(_.as[scala.Option[Event.Acknowledged]]),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(4).get).flatMap(_.as[scala.Option[Event.Launch]]),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(8).get).flatMap(_.as[scala.Option[Event.LaunchGroup]]),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(5).get).flatMap(_.as[scala.Option[Event.Kill]]),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(6).get).flatMap(_.as[scala.Option[Event.Message]]),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(7).get).flatMap(_.as[scala.Option[Event.Error]])
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = ExecutorProto.javaDescriptor.getMessageTypes.get(0)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = ExecutorProto.scalaDescriptor.messages(0)
  def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
    (__fieldNumber: @_root_.scala.unchecked) match {
      case 2 => __out = executor.Event.Subscribed
      case 3 => __out = executor.Event.Acknowledged
      case 4 => __out = executor.Event.Launch
      case 8 => __out = executor.Event.LaunchGroup
      case 5 => __out = executor.Event.Kill
      case 6 => __out = executor.Event.Message
      case 7 => __out = executor.Event.Error
    }
    __out
  }
  def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = {
    (__fieldNumber: @_root_.scala.unchecked) match {
      case 1 => executor.Event.Type
    }
  }
  lazy val defaultInstance = executor.Event(
  )
  sealed trait Type extends _root_.com.trueaccord.scalapb.GeneratedEnum {
    type EnumType = Type
    def isUnknown: Boolean = false
    def isSubscribed: Boolean = false
    def isLaunch: Boolean = false
    def isLaunchGroup: Boolean = false
    def isKill: Boolean = false
    def isAcknowledged: Boolean = false
    def isMessage: Boolean = false
    def isError: Boolean = false
    def isShutdown: Boolean = false
    def companion: _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[Type] = executor.Event.Type
  }
  
  object Type extends _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[Type] {
    implicit def enumCompanion: _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[Type] = this
    @SerialVersionUID(0L)
    case object UNKNOWN extends Type {
      val value = 0
      val index = 0
      val name = "UNKNOWN"
      override def isUnknown: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object SUBSCRIBED extends Type {
      val value = 1
      val index = 1
      val name = "SUBSCRIBED"
      override def isSubscribed: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object LAUNCH extends Type {
      val value = 2
      val index = 2
      val name = "LAUNCH"
      override def isLaunch: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object LAUNCH_GROUP extends Type {
      val value = 8
      val index = 3
      val name = "LAUNCH_GROUP"
      override def isLaunchGroup: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object KILL extends Type {
      val value = 3
      val index = 4
      val name = "KILL"
      override def isKill: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object ACKNOWLEDGED extends Type {
      val value = 4
      val index = 5
      val name = "ACKNOWLEDGED"
      override def isAcknowledged: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object MESSAGE extends Type {
      val value = 5
      val index = 6
      val name = "MESSAGE"
      override def isMessage: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object ERROR extends Type {
      val value = 6
      val index = 7
      val name = "ERROR"
      override def isError: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object SHUTDOWN extends Type {
      val value = 7
      val index = 8
      val name = "SHUTDOWN"
      override def isShutdown: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case class Unrecognized(value: Int) extends Type with _root_.com.trueaccord.scalapb.UnrecognizedEnum
    
    lazy val values = scala.collection.Seq(UNKNOWN, SUBSCRIBED, LAUNCH, LAUNCH_GROUP, KILL, ACKNOWLEDGED, MESSAGE, ERROR, SHUTDOWN)
    def fromValue(value: Int): Type = value match {
      case 0 => UNKNOWN
      case 1 => SUBSCRIBED
      case 2 => LAUNCH
      case 3 => KILL
      case 4 => ACKNOWLEDGED
      case 5 => MESSAGE
      case 6 => ERROR
      case 7 => SHUTDOWN
      case 8 => LAUNCH_GROUP
      case __other => Unrecognized(__other)
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.EnumDescriptor = executor.Event.javaDescriptor.getEnumTypes.get(0)
    def scalaDescriptor: _root_.scalapb.descriptors.EnumDescriptor = executor.Event.scalaDescriptor.enums(0)
  }
  /** First event received when the executor subscribes.
    * The 'id' field in the 'framework_info' will be set.
    *
    * @param containerId
    *   Uniquely identifies the container of an executor run.
    */
  @SerialVersionUID(0L)
  final case class Subscribed(
      executorInfo: org.apache.mesos.v1.mesos.ExecutorInfo,
      frameworkInfo: org.apache.mesos.v1.mesos.FrameworkInfo,
      agentInfo: org.apache.mesos.v1.mesos.AgentInfo,
      containerId: scala.Option[org.apache.mesos.v1.mesos.ContainerID] = None
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Subscribed] with com.trueaccord.lenses.Updatable[Subscribed] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(executorInfo.serializedSize) + executorInfo.serializedSize
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(frameworkInfo.serializedSize) + frameworkInfo.serializedSize
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(agentInfo.serializedSize) + agentInfo.serializedSize
        if (containerId.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(containerId.get.serializedSize) + containerId.get.serializedSize }
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(executorInfo.serializedSize)
        executorInfo.writeTo(_output__)
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(frameworkInfo.serializedSize)
        frameworkInfo.writeTo(_output__)
        _output__.writeTag(3, 2)
        _output__.writeUInt32NoTag(agentInfo.serializedSize)
        agentInfo.writeTo(_output__)
        containerId.foreach { __v =>
          _output__.writeTag(4, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        };
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): Event.Subscribed = {
        var __executorInfo = this.executorInfo
        var __frameworkInfo = this.frameworkInfo
        var __agentInfo = this.agentInfo
        var __containerId = this.containerId
        var __requiredFields0: Long = 0x7L
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __executorInfo = _root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __executorInfo)
              __requiredFields0 &= 0xfffffffffffffffeL
            case 18 =>
              __frameworkInfo = _root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __frameworkInfo)
              __requiredFields0 &= 0xfffffffffffffffdL
            case 26 =>
              __agentInfo = _root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __agentInfo)
              __requiredFields0 &= 0xfffffffffffffffbL
            case 34 =>
              __containerId = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __containerId.getOrElse(org.apache.mesos.v1.mesos.ContainerID.defaultInstance)))
            case tag => _input__.skipField(tag)
          }
        }
        if (__requiredFields0 != 0L) { throw new _root_.com.google.protobuf.InvalidProtocolBufferException("Message missing required fields.") } 
        executor.Event.Subscribed(
            executorInfo = __executorInfo,
            frameworkInfo = __frameworkInfo,
            agentInfo = __agentInfo,
            containerId = __containerId
        )
      }
      def withExecutorInfo(__v: org.apache.mesos.v1.mesos.ExecutorInfo): Subscribed = copy(executorInfo = __v)
      def withFrameworkInfo(__v: org.apache.mesos.v1.mesos.FrameworkInfo): Subscribed = copy(frameworkInfo = __v)
      def withAgentInfo(__v: org.apache.mesos.v1.mesos.AgentInfo): Subscribed = copy(agentInfo = __v)
      def getContainerId: org.apache.mesos.v1.mesos.ContainerID = containerId.getOrElse(org.apache.mesos.v1.mesos.ContainerID.defaultInstance)
      def clearContainerId: Subscribed = copy(containerId = None)
      def withContainerId(__v: org.apache.mesos.v1.mesos.ContainerID): Subscribed = copy(containerId = Some(__v))
      def getFieldByNumber(__fieldNumber: Int): scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => executorInfo
          case 2 => frameworkInfo
          case 3 => agentInfo
          case 4 => containerId.orNull
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => executorInfo.toPMessage
          case 2 => frameworkInfo.toPMessage
          case 3 => agentInfo.toPMessage
          case 4 => containerId.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        }
      }
      override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = executor.Event.Subscribed
  }
  
  object Subscribed extends com.trueaccord.scalapb.GeneratedMessageCompanion[Event.Subscribed] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Event.Subscribed] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): Event.Subscribed = {
      require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      executor.Event.Subscribed(
        __fieldsMap(__fields.get(0)).asInstanceOf[org.apache.mesos.v1.mesos.ExecutorInfo],
        __fieldsMap(__fields.get(1)).asInstanceOf[org.apache.mesos.v1.mesos.FrameworkInfo],
        __fieldsMap(__fields.get(2)).asInstanceOf[org.apache.mesos.v1.mesos.AgentInfo],
        __fieldsMap.get(__fields.get(3)).asInstanceOf[scala.Option[org.apache.mesos.v1.mesos.ContainerID]]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[Event.Subscribed] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        executor.Event.Subscribed(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).get.as[org.apache.mesos.v1.mesos.ExecutorInfo],
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).get.as[org.apache.mesos.v1.mesos.FrameworkInfo],
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).get.as[org.apache.mesos.v1.mesos.AgentInfo],
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(4).get).flatMap(_.as[scala.Option[org.apache.mesos.v1.mesos.ContainerID]])
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = executor.Event.javaDescriptor.getNestedTypes.get(0)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = executor.Event.scalaDescriptor.nestedMessages(0)
    def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
      var __out: _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => __out = org.apache.mesos.v1.mesos.ExecutorInfo
        case 2 => __out = org.apache.mesos.v1.mesos.FrameworkInfo
        case 3 => __out = org.apache.mesos.v1.mesos.AgentInfo
        case 4 => __out = org.apache.mesos.v1.mesos.ContainerID
      }
      __out
    }
    def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = executor.Event.Subscribed(
      executorInfo = org.apache.mesos.v1.mesos.ExecutorInfo.defaultInstance,
      frameworkInfo = org.apache.mesos.v1.mesos.FrameworkInfo.defaultInstance,
      agentInfo = org.apache.mesos.v1.mesos.AgentInfo.defaultInstance
    )
    implicit class SubscribedLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, Event.Subscribed]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, Event.Subscribed](_l) {
      def executorInfo: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.ExecutorInfo] = field(_.executorInfo)((c_, f_) => c_.copy(executorInfo = f_))
      def frameworkInfo: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.FrameworkInfo] = field(_.frameworkInfo)((c_, f_) => c_.copy(frameworkInfo = f_))
      def agentInfo: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.AgentInfo] = field(_.agentInfo)((c_, f_) => c_.copy(agentInfo = f_))
      def containerId: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.ContainerID] = field(_.getContainerId)((c_, f_) => c_.copy(containerId = Some(f_)))
      def optionalContainerId: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[org.apache.mesos.v1.mesos.ContainerID]] = field(_.containerId)((c_, f_) => c_.copy(containerId = f_))
    }
    final val EXECUTOR_INFO_FIELD_NUMBER = 1
    final val FRAMEWORK_INFO_FIELD_NUMBER = 2
    final val AGENT_INFO_FIELD_NUMBER = 3
    final val CONTAINER_ID_FIELD_NUMBER = 4
  }
  
  /** Received when the framework attempts to launch a task. Once
    * the task is successfully launched, the executor must respond with
    * a TASK_RUNNING update (See TaskState in v1/mesos.proto).
    */
  @SerialVersionUID(0L)
  final case class Launch(
      task: org.apache.mesos.v1.mesos.TaskInfo
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Launch] with com.trueaccord.lenses.Updatable[Launch] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(task.serializedSize) + task.serializedSize
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(task.serializedSize)
        task.writeTo(_output__)
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): Event.Launch = {
        var __task = this.task
        var __requiredFields0: Long = 0x1L
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __task = _root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __task)
              __requiredFields0 &= 0xfffffffffffffffeL
            case tag => _input__.skipField(tag)
          }
        }
        if (__requiredFields0 != 0L) { throw new _root_.com.google.protobuf.InvalidProtocolBufferException("Message missing required fields.") } 
        executor.Event.Launch(
            task = __task
        )
      }
      def withTask(__v: org.apache.mesos.v1.mesos.TaskInfo): Launch = copy(task = __v)
      def getFieldByNumber(__fieldNumber: Int): scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => task
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => task.toPMessage
        }
      }
      override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = executor.Event.Launch
  }
  
  object Launch extends com.trueaccord.scalapb.GeneratedMessageCompanion[Event.Launch] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Event.Launch] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): Event.Launch = {
      require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      executor.Event.Launch(
        __fieldsMap(__fields.get(0)).asInstanceOf[org.apache.mesos.v1.mesos.TaskInfo]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[Event.Launch] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        executor.Event.Launch(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).get.as[org.apache.mesos.v1.mesos.TaskInfo]
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = executor.Event.javaDescriptor.getNestedTypes.get(1)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = executor.Event.scalaDescriptor.nestedMessages(1)
    def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
      var __out: _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => __out = org.apache.mesos.v1.mesos.TaskInfo
      }
      __out
    }
    def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = executor.Event.Launch(
      task = org.apache.mesos.v1.mesos.TaskInfo.defaultInstance
    )
    implicit class LaunchLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, Event.Launch]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, Event.Launch](_l) {
      def task: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.TaskInfo] = field(_.task)((c_, f_) => c_.copy(task = f_))
    }
    final val TASK_FIELD_NUMBER = 1
  }
  
  /** Received when the framework attempts to launch a group of tasks atomically.
    * Similar to `Launch` above the executor must send TASK_RUNNING updates for
    * tasks that are successfully launched.
    */
  @SerialVersionUID(0L)
  final case class LaunchGroup(
      taskGroup: org.apache.mesos.v1.mesos.TaskGroupInfo
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[LaunchGroup] with com.trueaccord.lenses.Updatable[LaunchGroup] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(taskGroup.serializedSize) + taskGroup.serializedSize
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(taskGroup.serializedSize)
        taskGroup.writeTo(_output__)
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): Event.LaunchGroup = {
        var __taskGroup = this.taskGroup
        var __requiredFields0: Long = 0x1L
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __taskGroup = _root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __taskGroup)
              __requiredFields0 &= 0xfffffffffffffffeL
            case tag => _input__.skipField(tag)
          }
        }
        if (__requiredFields0 != 0L) { throw new _root_.com.google.protobuf.InvalidProtocolBufferException("Message missing required fields.") } 
        executor.Event.LaunchGroup(
            taskGroup = __taskGroup
        )
      }
      def withTaskGroup(__v: org.apache.mesos.v1.mesos.TaskGroupInfo): LaunchGroup = copy(taskGroup = __v)
      def getFieldByNumber(__fieldNumber: Int): scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => taskGroup
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => taskGroup.toPMessage
        }
      }
      override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = executor.Event.LaunchGroup
  }
  
  object LaunchGroup extends com.trueaccord.scalapb.GeneratedMessageCompanion[Event.LaunchGroup] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Event.LaunchGroup] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): Event.LaunchGroup = {
      require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      executor.Event.LaunchGroup(
        __fieldsMap(__fields.get(0)).asInstanceOf[org.apache.mesos.v1.mesos.TaskGroupInfo]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[Event.LaunchGroup] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        executor.Event.LaunchGroup(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).get.as[org.apache.mesos.v1.mesos.TaskGroupInfo]
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = executor.Event.javaDescriptor.getNestedTypes.get(2)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = executor.Event.scalaDescriptor.nestedMessages(2)
    def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
      var __out: _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => __out = org.apache.mesos.v1.mesos.TaskGroupInfo
      }
      __out
    }
    def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = executor.Event.LaunchGroup(
      taskGroup = org.apache.mesos.v1.mesos.TaskGroupInfo.defaultInstance
    )
    implicit class LaunchGroupLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, Event.LaunchGroup]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, Event.LaunchGroup](_l) {
      def taskGroup: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.TaskGroupInfo] = field(_.taskGroup)((c_, f_) => c_.copy(taskGroup = f_))
    }
    final val TASK_GROUP_FIELD_NUMBER = 1
  }
  
  /** Received when the scheduler wants to kill a specific task. Once
    * the task is terminated, the executor should send a TASK_KILLED
    * (or TASK_FAILED) update. The terminal update is necessary so
    * Mesos can release the resources associated with the task.
    *
    * @param killPolicy
    *   If set, overrides any previously specified kill policy for this task.
    *   This includes 'TaskInfo.kill_policy' and 'Executor.kill.kill_policy'.
    *   Can be used to forcefully kill a task which is already being killed.
    */
  @SerialVersionUID(0L)
  final case class Kill(
      taskId: org.apache.mesos.v1.mesos.TaskID,
      killPolicy: scala.Option[org.apache.mesos.v1.mesos.KillPolicy] = None
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Kill] with com.trueaccord.lenses.Updatable[Kill] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(taskId.serializedSize) + taskId.serializedSize
        if (killPolicy.isDefined) { __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(killPolicy.get.serializedSize) + killPolicy.get.serializedSize }
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(taskId.serializedSize)
        taskId.writeTo(_output__)
        killPolicy.foreach { __v =>
          _output__.writeTag(2, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        };
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): Event.Kill = {
        var __taskId = this.taskId
        var __killPolicy = this.killPolicy
        var __requiredFields0: Long = 0x1L
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __taskId = _root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __taskId)
              __requiredFields0 &= 0xfffffffffffffffeL
            case 18 =>
              __killPolicy = Some(_root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __killPolicy.getOrElse(org.apache.mesos.v1.mesos.KillPolicy.defaultInstance)))
            case tag => _input__.skipField(tag)
          }
        }
        if (__requiredFields0 != 0L) { throw new _root_.com.google.protobuf.InvalidProtocolBufferException("Message missing required fields.") } 
        executor.Event.Kill(
            taskId = __taskId,
            killPolicy = __killPolicy
        )
      }
      def withTaskId(__v: org.apache.mesos.v1.mesos.TaskID): Kill = copy(taskId = __v)
      def getKillPolicy: org.apache.mesos.v1.mesos.KillPolicy = killPolicy.getOrElse(org.apache.mesos.v1.mesos.KillPolicy.defaultInstance)
      def clearKillPolicy: Kill = copy(killPolicy = None)
      def withKillPolicy(__v: org.apache.mesos.v1.mesos.KillPolicy): Kill = copy(killPolicy = Some(__v))
      def getFieldByNumber(__fieldNumber: Int): scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => taskId
          case 2 => killPolicy.orNull
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => taskId.toPMessage
          case 2 => killPolicy.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        }
      }
      override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = executor.Event.Kill
  }
  
  object Kill extends com.trueaccord.scalapb.GeneratedMessageCompanion[Event.Kill] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Event.Kill] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): Event.Kill = {
      require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      executor.Event.Kill(
        __fieldsMap(__fields.get(0)).asInstanceOf[org.apache.mesos.v1.mesos.TaskID],
        __fieldsMap.get(__fields.get(1)).asInstanceOf[scala.Option[org.apache.mesos.v1.mesos.KillPolicy]]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[Event.Kill] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        executor.Event.Kill(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).get.as[org.apache.mesos.v1.mesos.TaskID],
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[scala.Option[org.apache.mesos.v1.mesos.KillPolicy]])
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = executor.Event.javaDescriptor.getNestedTypes.get(3)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = executor.Event.scalaDescriptor.nestedMessages(3)
    def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
      var __out: _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => __out = org.apache.mesos.v1.mesos.TaskID
        case 2 => __out = org.apache.mesos.v1.mesos.KillPolicy
      }
      __out
    }
    def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = executor.Event.Kill(
      taskId = org.apache.mesos.v1.mesos.TaskID.defaultInstance
    )
    implicit class KillLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, Event.Kill]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, Event.Kill](_l) {
      def taskId: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.TaskID] = field(_.taskId)((c_, f_) => c_.copy(taskId = f_))
      def killPolicy: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.KillPolicy] = field(_.getKillPolicy)((c_, f_) => c_.copy(killPolicy = Some(f_)))
      def optionalKillPolicy: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[org.apache.mesos.v1.mesos.KillPolicy]] = field(_.killPolicy)((c_, f_) => c_.copy(killPolicy = f_))
    }
    final val TASK_ID_FIELD_NUMBER = 1
    final val KILL_POLICY_FIELD_NUMBER = 2
  }
  
  /** Received when the agent acknowledges the receipt of status
    * update. Schedulers are responsible for explicitly acknowledging
    * the receipt of status updates that have 'update.status().uuid()'
    * field set. Unacknowledged updates can be retried by the executor.
    * They should also be sent by the executor whenever it
    * re-subscribes.
    */
  @SerialVersionUID(0L)
  final case class Acknowledged(
      taskId: org.apache.mesos.v1.mesos.TaskID,
      uuid: _root_.com.google.protobuf.ByteString
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Acknowledged] with com.trueaccord.lenses.Updatable[Acknowledged] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(taskId.serializedSize) + taskId.serializedSize
        __size += _root_.com.google.protobuf.CodedOutputStream.computeBytesSize(2, uuid)
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(taskId.serializedSize)
        taskId.writeTo(_output__)
        _output__.writeBytes(2, uuid)
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): Event.Acknowledged = {
        var __taskId = this.taskId
        var __uuid = this.uuid
        var __requiredFields0: Long = 0x3L
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __taskId = _root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, __taskId)
              __requiredFields0 &= 0xfffffffffffffffeL
            case 18 =>
              __uuid = _input__.readBytes()
              __requiredFields0 &= 0xfffffffffffffffdL
            case tag => _input__.skipField(tag)
          }
        }
        if (__requiredFields0 != 0L) { throw new _root_.com.google.protobuf.InvalidProtocolBufferException("Message missing required fields.") } 
        executor.Event.Acknowledged(
            taskId = __taskId,
            uuid = __uuid
        )
      }
      def withTaskId(__v: org.apache.mesos.v1.mesos.TaskID): Acknowledged = copy(taskId = __v)
      def withUuid(__v: _root_.com.google.protobuf.ByteString): Acknowledged = copy(uuid = __v)
      def getFieldByNumber(__fieldNumber: Int): scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => taskId
          case 2 => uuid
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => taskId.toPMessage
          case 2 => _root_.scalapb.descriptors.PByteString(uuid)
        }
      }
      override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = executor.Event.Acknowledged
  }
  
  object Acknowledged extends com.trueaccord.scalapb.GeneratedMessageCompanion[Event.Acknowledged] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Event.Acknowledged] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): Event.Acknowledged = {
      require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      executor.Event.Acknowledged(
        __fieldsMap(__fields.get(0)).asInstanceOf[org.apache.mesos.v1.mesos.TaskID],
        __fieldsMap(__fields.get(1)).asInstanceOf[_root_.com.google.protobuf.ByteString]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[Event.Acknowledged] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        executor.Event.Acknowledged(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).get.as[org.apache.mesos.v1.mesos.TaskID],
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).get.as[_root_.com.google.protobuf.ByteString]
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = executor.Event.javaDescriptor.getNestedTypes.get(4)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = executor.Event.scalaDescriptor.nestedMessages(4)
    def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
      var __out: _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => __out = org.apache.mesos.v1.mesos.TaskID
      }
      __out
    }
    def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = executor.Event.Acknowledged(
      taskId = org.apache.mesos.v1.mesos.TaskID.defaultInstance,
      uuid = _root_.com.google.protobuf.ByteString.EMPTY
    )
    implicit class AcknowledgedLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, Event.Acknowledged]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, Event.Acknowledged](_l) {
      def taskId: _root_.com.trueaccord.lenses.Lens[UpperPB, org.apache.mesos.v1.mesos.TaskID] = field(_.taskId)((c_, f_) => c_.copy(taskId = f_))
      def uuid: _root_.com.trueaccord.lenses.Lens[UpperPB, _root_.com.google.protobuf.ByteString] = field(_.uuid)((c_, f_) => c_.copy(uuid = f_))
    }
    final val TASK_ID_FIELD_NUMBER = 1
    final val UUID_FIELD_NUMBER = 2
  }
  
  /** Received when a custom message generated by the scheduler is
    * forwarded by the agent. Note that this message is not
    * interpreted by Mesos and is only forwarded (without reliability
    * guarantees) to the executor. It is up to the scheduler to retry
    * if the message is dropped for any reason.
    */
  @SerialVersionUID(0L)
  final case class Message(
      data: _root_.com.google.protobuf.ByteString
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Message] with com.trueaccord.lenses.Updatable[Message] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        __size += _root_.com.google.protobuf.CodedOutputStream.computeBytesSize(1, data)
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
        _output__.writeBytes(1, data)
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): Event.Message = {
        var __data = this.data
        var __requiredFields0: Long = 0x1L
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __data = _input__.readBytes()
              __requiredFields0 &= 0xfffffffffffffffeL
            case tag => _input__.skipField(tag)
          }
        }
        if (__requiredFields0 != 0L) { throw new _root_.com.google.protobuf.InvalidProtocolBufferException("Message missing required fields.") } 
        executor.Event.Message(
            data = __data
        )
      }
      def withData(__v: _root_.com.google.protobuf.ByteString): Message = copy(data = __v)
      def getFieldByNumber(__fieldNumber: Int): scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => data
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => _root_.scalapb.descriptors.PByteString(data)
        }
      }
      override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = executor.Event.Message
  }
  
  object Message extends com.trueaccord.scalapb.GeneratedMessageCompanion[Event.Message] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Event.Message] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): Event.Message = {
      require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      executor.Event.Message(
        __fieldsMap(__fields.get(0)).asInstanceOf[_root_.com.google.protobuf.ByteString]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[Event.Message] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        executor.Event.Message(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).get.as[_root_.com.google.protobuf.ByteString]
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = executor.Event.javaDescriptor.getNestedTypes.get(5)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = executor.Event.scalaDescriptor.nestedMessages(5)
    def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__fieldNumber)
    def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = executor.Event.Message(
      data = _root_.com.google.protobuf.ByteString.EMPTY
    )
    implicit class MessageLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, Event.Message]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, Event.Message](_l) {
      def data: _root_.com.trueaccord.lenses.Lens[UpperPB, _root_.com.google.protobuf.ByteString] = field(_.data)((c_, f_) => c_.copy(data = f_))
    }
    final val DATA_FIELD_NUMBER = 1
  }
  
  /** Received in case the executor sends invalid calls (e.g.,
    * required values not set).
    * TODO(arojas): Remove this once the old executor driver is no
    * longer supported. With HTTP API all errors will be signaled via
    * HTTP response codes.
    */
  @SerialVersionUID(0L)
  final case class Error(
      message: String
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Error] with com.trueaccord.lenses.Updatable[Error] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, message)
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
        _output__.writeString(1, message)
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): Event.Error = {
        var __message = this.message
        var __requiredFields0: Long = 0x1L
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __message = _input__.readString()
              __requiredFields0 &= 0xfffffffffffffffeL
            case tag => _input__.skipField(tag)
          }
        }
        if (__requiredFields0 != 0L) { throw new _root_.com.google.protobuf.InvalidProtocolBufferException("Message missing required fields.") } 
        executor.Event.Error(
            message = __message
        )
      }
      def withMessage(__v: String): Error = copy(message = __v)
      def getFieldByNumber(__fieldNumber: Int): scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => message
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => _root_.scalapb.descriptors.PString(message)
        }
      }
      override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = executor.Event.Error
  }
  
  object Error extends com.trueaccord.scalapb.GeneratedMessageCompanion[Event.Error] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[Event.Error] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): Event.Error = {
      require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      executor.Event.Error(
        __fieldsMap(__fields.get(0)).asInstanceOf[String]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[Event.Error] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        executor.Event.Error(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).get.as[String]
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = executor.Event.javaDescriptor.getNestedTypes.get(6)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = executor.Event.scalaDescriptor.nestedMessages(6)
    def messageCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__fieldNumber)
    def enumCompanionForFieldNumber(__fieldNumber: Int): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = executor.Event.Error(
      message = ""
    )
    implicit class ErrorLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, Event.Error]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, Event.Error](_l) {
      def message: _root_.com.trueaccord.lenses.Lens[UpperPB, String] = field(_.message)((c_, f_) => c_.copy(message = f_))
    }
    final val MESSAGE_FIELD_NUMBER = 1
  }
  
  implicit class EventLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, Event]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, Event](_l) {
    def `type`: _root_.com.trueaccord.lenses.Lens[UpperPB, Event.Type] = field(_.getType)((c_, f_) => c_.copy(`type` = Some(f_)))
    def optionalType: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Event.Type]] = field(_.`type`)((c_, f_) => c_.copy(`type` = f_))
    def subscribed: _root_.com.trueaccord.lenses.Lens[UpperPB, Event.Subscribed] = field(_.getSubscribed)((c_, f_) => c_.copy(subscribed = Some(f_)))
    def optionalSubscribed: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Event.Subscribed]] = field(_.subscribed)((c_, f_) => c_.copy(subscribed = f_))
    def acknowledged: _root_.com.trueaccord.lenses.Lens[UpperPB, Event.Acknowledged] = field(_.getAcknowledged)((c_, f_) => c_.copy(acknowledged = Some(f_)))
    def optionalAcknowledged: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Event.Acknowledged]] = field(_.acknowledged)((c_, f_) => c_.copy(acknowledged = f_))
    def launch: _root_.com.trueaccord.lenses.Lens[UpperPB, Event.Launch] = field(_.getLaunch)((c_, f_) => c_.copy(launch = Some(f_)))
    def optionalLaunch: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Event.Launch]] = field(_.launch)((c_, f_) => c_.copy(launch = f_))
    def launchGroup: _root_.com.trueaccord.lenses.Lens[UpperPB, Event.LaunchGroup] = field(_.getLaunchGroup)((c_, f_) => c_.copy(launchGroup = Some(f_)))
    def optionalLaunchGroup: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Event.LaunchGroup]] = field(_.launchGroup)((c_, f_) => c_.copy(launchGroup = f_))
    def kill: _root_.com.trueaccord.lenses.Lens[UpperPB, Event.Kill] = field(_.getKill)((c_, f_) => c_.copy(kill = Some(f_)))
    def optionalKill: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Event.Kill]] = field(_.kill)((c_, f_) => c_.copy(kill = f_))
    def message: _root_.com.trueaccord.lenses.Lens[UpperPB, Event.Message] = field(_.getMessage)((c_, f_) => c_.copy(message = Some(f_)))
    def optionalMessage: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Event.Message]] = field(_.message)((c_, f_) => c_.copy(message = f_))
    def error: _root_.com.trueaccord.lenses.Lens[UpperPB, Event.Error] = field(_.getError)((c_, f_) => c_.copy(error = Some(f_)))
    def optionalError: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Event.Error]] = field(_.error)((c_, f_) => c_.copy(error = f_))
  }
  final val TYPE_FIELD_NUMBER = 1
  final val SUBSCRIBED_FIELD_NUMBER = 2
  final val ACKNOWLEDGED_FIELD_NUMBER = 3
  final val LAUNCH_FIELD_NUMBER = 4
  final val LAUNCH_GROUP_FIELD_NUMBER = 8
  final val KILL_FIELD_NUMBER = 5
  final val MESSAGE_FIELD_NUMBER = 6
  final val ERROR_FIELD_NUMBER = 7
}
